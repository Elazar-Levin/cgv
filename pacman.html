<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>Pacman</title>
<style>
#glcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
}
</style>
<script src="sources/three.js"></script>
<script src="sources/OrbitControls.js"></script>
<script src="sources/stats.js"></script>
<script>



"use strict";

var canvas, renderer, scene, camera,stats; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.


var pacman;//yellow ball shaped thing with huge mouth
var pacMouth;//inside of yellow ball shaped thing with huge mouth
var pacmanGeometries = [];//set of animations for outer pacman
var pacMouthGeometries = [];//set of animations for innerpacman
var floor;//main ground platform that everything stands on
var pellet;//food pellet

var level=0;// current floor pacman is on, so we can do collisions
var cameraMode=1;//3 modes, depending on which number button pressed eg. 1 is fixed full view,2 is 3rd person, 3 is 1st person// not properly done yet

var lrAcceleration=0;//left/right acceleration
var fbAcceleration=0;//forward/backward acceleration

var MAX_ACCELERATION=0.2;//fastest speed pacman can achieve
var VETICAL_VELOCITY=0.05;//speed pacman falls if not on ground(gravity kinda)
var PAC_RADIUS=2;//size of pacman
var PAC_SPEED=0.01;//horizontal speed.because pacman accelerates over time, this needs to be low or hell go out of control 


var myPac;//actual full pacman object that well be moving around
/**
 *  The render function draws the scene.
 */
function render() {
    renderer.render(scene, camera);
	
}


/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
	myPac = new THREE.Object3D(); //holds full pacman object	
		
		
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Setup cameras and lights ----------------------
    
    camera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 100);//main camera, staionary,can be used later for fixed full view with different parameters 
    camera.position.z = 30;
    var light;  // A light shining from the top of pacman(looks really cool).
	var light2;//a general light at the top of the screen
	//TODO: add ligt underneath pacman so hes not in shadow
	var halloweenLight;
    halloweenLight = new THREE.PointLight(0xffffff,1,0,2);//add this light to myPac, and disable all other lights for an awesome spooky effect
	light= new THREE.PointLight(0xffffff,0.5,0,2);
    light2 = new THREE.PointLight(0xffffff,1,0,1);
    light.position.set(0,10,0);
    light2.position.set(0,30,0);
	myPac.add(light);
    scene.add(light2);
	
	
	//myPac.add(camera);//looks weird, because all of backgound is the same.
    scene.add(camera);
    resize();//allows game to be fullscreen without blurring
	var gl = canvas.getContext("webgl");
	gl.viewport(0, 0, canvas.width, canvas.height);// makes the viewport the same size as the canvas
    //------------------- Create the scene's visible objects ----------------------
 
	
	
	
	
	
	
    var numFrames = 40;
    var offset;
    for (var i = 0; i < numFrames; i++) {// create the frames for pacmans animations
        offset = (i / (numFrames - 1)) * Math.PI;
        pacmanGeometries.push(new THREE.SphereGeometry(PAC_RADIUS, 16, 16, offset, Math.PI * 2 - offset * 2));
        pacMouthGeometries.push(new THREE.SphereGeometry(PAC_RADIUS-0.010001, 16, 16, offset, Math.PI *2 - offset * 2));
        pacmanGeometries[i].rotateX(Math.PI / 2);
        pacMouthGeometries[i].rotateX(Math.PI / 2);
    }

    var pacmanMaterial = new THREE.MeshPhongMaterial({ color: 'yellow', side: THREE.DoubleSide });
	
	var pacMouthMaterial=new THREE.MeshBasicMaterial({ color: 'red', side: THREE.DoubleSide });
	
	
	var eyeMaterial=new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	var pacGeometry=new THREE.SphereGeometry(0.3,16,16);
	
	
	pellet=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshPhongMaterial({color:'white',side: THREE.DoubleSide}));
	pellet.position.set(3.5,-3,3.5);
	
	floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshPhongMaterial({color:'green',side: THREE.DoubleSide}));
	floor.position.set(0,-5,0);
	floor.rotation.x=Math.PI/2;//make floor on bottom 
	
	pacman=new THREE.Mesh(pacmanGeometries[10],pacmanMaterial);
	pacMouth=new THREE.Mesh(pacMouthGeometries[10],pacMouthMaterial);	
	var pacEye=new THREE.Mesh(pacGeometry,eyeMaterial);
	
	pacEye.position.set(-1,0.7,2);
	
	
	var starsGeometry = new THREE.Geometry();

for ( var i = 0; i < 10000; i ++ ) {

	var star = new THREE.Vector3();
	star.x = THREE.Math.randFloatSpread( 100 );
	star.y = THREE.Math.randFloatSpread( 100 );
	star.z = THREE.Math.randFloatSpread( 100 );

	starsGeometry.vertices.push( star );

}

var starsMaterial = new THREE.PointsMaterial( { color: 0x888888 } );

var starField = new THREE.Points( starsGeometry, starsMaterial );

scene.add( starField );
	
	
	
	myPac.add(pacMouth);
	myPac.add(pacman);
	//myPac.add(pacEye);
	

	scene.add(floor);
    scene.add(myPac);
	scene.add(pellet);
} // end function createWorld()


function createStats() //allows us to see the frames per second, and the graph. change setMode to 1 to see the time taken to render each frame
{
      var stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';

      return stats;
}





/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
 
 
 
 
 
function updateForFrame() {
    
    // Update size and rotation of tempObject.  DELETE THIS!
   
    
	
    

 

	var paccy = frameNumber % 20;
    if (paccy > 10) {//do opening and closing of mouth animation
        paccy = 20 - paccy;
    }
	
	pacman.geometry=pacmanGeometries[paccy];
	pacMouth.geometry=pacMouthGeometries[paccy];
	if(level==0)//if still on ground floor
	{
		if(myPac.position.y-PAC_RADIUS-0.001>=floor.position.y)//stay on floor
		{
			
			myPac.position.y-=VETICAL_VELOCITY;
		
		
		
		}
	}
	//TODO:Consider resseting fbAcceleration when moving left and right, and vice versa(give opinions)
	myPac.position.x+=fbAcceleration;//update forward and backward positions
	myPac.position.z+=lrAcceleration;//update left and right positions
	
	
	
	
	
	
	
	
	
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        
        render();
    
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}



/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
	frameNumber++;
	updateForFrame();
	render();
	stats.update();
	requestAnimationFrame(doFrame);

}


function onDocumentKeyDown(event) {//TODO: introduce keyup event, and then add accelearation, so when you stop its gradual not sudden
//TODO: when two cameras are introduced, use position relative to player(world) for zoomed out view, relative to character for 3rd person.
    var keyCode = event.which;
    if (keyCode == 87 || keyCode== 40) {//s
		//myPac.position.x -= PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		if(fbAcceleration>=-MAX_ACCELERATION)
		{
			fbAcceleration -= PAC_SPEED;
			lrAcceleration=0;//put back in to make him only go forward and backward or left and right, not both
		}
		//back
		myPac.rotation.y=0;
				
    } else if (keyCode == 83 || keyCode==38) {//w
		if(fbAcceleration<=MAX_ACCELERATION)
		{
			fbAcceleration+=PAC_SPEED;
			lrAcceleration=0;//comment out to make him go both left/right and forward/backward at the same time
		}
		//myPac.position.x += PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		//forward
		myPac.rotation.y=Math.PI;
		
    } else if (keyCode == 65 || keyCode==37) {//a
	    //myPac.position.z += PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		if(lrAcceleration<=MAX_ACCELERATION)
		{
			lrAcceleration += PAC_SPEED;
			fbAcceleration=0; //comment out to make him go both left/right and forward/backward at the same time
		}
		//left
		myPac.rotation.y=Math.PI/2;
		
    } else if (keyCode == 68 || keyCode==39) {//d
       // myPac.position.z -= PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		if(lrAcceleration>=-MAX_ACCELERATION)
		{
			lrAcceleration-=PAC_SPEED;
			fbAcceleration=0;// comment out to make him go both left/right and forward/backward at the same time
		}
		//right
		myPac.rotation.y=-Math.PI/2;
		
    } else if (keyCode == 32) {//space
        myPac.position.set(0, 0, 0);
		lrAcceleration=0;
		fbAcceleration=0;
    }
	else if(keyCode==49)//1
	{
		cameraMode=1;
	}
	else if(keyCode==50)//2
	{
		cameraMode=2;
	}
	else if(keyCode==51)//3
	{
		cameraMode=3;
	}
	
};

function resize()
{
	var displayWidth  = canvas.clientWidth;
	var displayHeight = canvas.clientHeight;
 
	// Check if the canvas is not the same size.
	if (canvas.width  != displayWidth || canvas.height != displayHeight) 
	{
 
		// Make the canvas the same size
		canvas.width  = displayWidth;
		canvas.height = displayHeight;
	}


}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        canvas = document.getElementById("glcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
	requestAnimationFrame(doFrame);
	stats=createStats();
	document.body.appendChild( stats.domElement );
	document.addEventListener("keydown", onDocumentKeyDown, false);
    createWorld();
    installOrbitControls();
    render();
	
}

</script>
</head>
<body onload="init()">


<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>


<canvas width="window.innerWidth" height="window.innerHeight" id="glcanvas"></canvas>


</body>
</html>
