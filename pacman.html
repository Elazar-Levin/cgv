
<!DOCTYPE html>

<head>
<meta charset="UTF-8">
<title>Pacman</title>
<style>
#glcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
}
#hud {
	position: absolute;
	bottom: 10px;
	left :10px;
	text-align: left;
	z-index: 100;
	display:block;
}
#hud2 {
	position: absolute;
	bottom: 10px;
	left :1870px;
	text-align: left;
	z-index: 100;
	display:block;
}
#map {
    position: fixed;
    top: 0;
    right: 0;
    width: 200px;
    height: 200px;
    z-index: 100;
}
#endScreen {
	position: fixed;
	z-index: 101;
	width: 100%;
	height: 100%;
	left:-200;
    top:-200;
	
}
#endScreenContent {
	width: 100%;
	height: 100%;
	background-color: white;
	text-align: center;
	background-image: url("sources/bg.png");
	background-color: #053E18;
	background-repeat: no-repeat;
	background-size:cover;
}
.btn {
  background-image: url("sources/speaker-off-small.png");
  background-repeat: no-repeat;
  background-color: #ffffff;
  background-size: contain;
  border: none;
  padding: 17px 17px;
  font-size: 16px;
  cursor: pointer;
}

<!--/*#hudcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
    opacity: 0.5;
}*/-->
</style>


<script src="sources/three.js"></script>

<script src="sources/OrbitControls.js"></script>
<script src="sources/stats.js"></script>
<script src="sources/Character.js"></script>

<script>

"use strict";

var canvas, renderer, scene, camera,stats; // Standard three.js requirements.

var minimapCanvas,minmapRenderer;//minimap stuff


var skyboxMesh;

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

var pacman;//yellow ball shaped thing with huge mouth
var pacMouth;//inside of yellow ball shaped thing with huge mouth
var pacmanGeometries = [];//set of animations for outer pacman
var pacMouthGeometries = [];//set of animations for innerpacman
var floor;//main ground platform that everything stands on
var pellet;//food pellet
var wall;//basic obstruction
var objPac;//pacman created by Character.js. 
var sun;//pixelated sun object, made of blocks, with glow inside
var cloud;//pixelated cloud object
var sunBlock;
var cloudBlock;
var powerPellet;
var ghost1;//first ghost made by character.js
var ghost1Geometries=[];


var clouds;// object containing pixelated cloud objects
var pellets;//Object3D containing all pellets
var obstructions;//Object3D containing all walls/obstructions
var surfaces;//Object3D containing all the surfaces that characters can walk on//doesnt work
var powerPellets;//Object3D containing all powerPellets

var level=0;// current floor pacman is on, so we can do collisions
var cameraMode=1;//3 modes, depending on which number button pressed eg. 1 is fixed full view,2 is 3rd person, 3 is 1st person// not properly done yet
var halloween=false;//whether halloween mode is on
var powerMode=false;
var powerPelletEaten=false;


var mainCamera;
var thirdCamera;
var miniMapCamera;

var pelletsLeft=true;

var score;
var hiScore=0;

var powerPelletTimer=0;
var ghostRespawn = 0;

var lrAcceleration=0;//left/right acceleration
var fbAcceleration=0;//forward/backward acceleration

const GRAVITY_CONSTANT=0.1;//speed pacman falls if not on ground(gravity kinda)
const PAC_RADIUS=2;//size of pacman
const PAC_SPEED=0.5//speed //apparently has to have very specific values 

var light;  // A light shining from the top of pacman(looks really cool).
var light2;//a general light at the top of the screen
//TODO: add ligt underneath pacman so hes not in shadow
var halloweenLight;
var light3;//light illuminating block



var canvas2;
var destCtx;
var ctx;
var mute = false;
var first = true;
/*var sceneHUD;
var cameraHUD;
var hudBitmap;
var hudTexture;
var material;
var plane;
var planeGeometry;*/

var levelNo=1;
var dir = 1;

var map=[];
var canDie = true;


/**
 *  The render function draws the scene.
 */
function render() 
{
    renderer.render(scene, camera);
	//make shit more visible
	objPac.scale.set(2,2,2);
	ghost1.scale.set(2,2,2);
	for(var i=0;i<pellets.children.length;i++)
	{
		pellets.children[i].scale.set(3,3,3);
		
		
	}	
	for(var i=0;i<powerPellets.children.length;i++)
	{
		powerPellets.children[i].scale.set(3,3,3);
		
	}
	pellet.material.emissive.set('white');	
	powerPellet.material.emissive.set('yellow');

    minmapRenderer.render(scene, miniMapCamera);
	//make shit less visible

	objPac.scale.set(1,1,1);
	ghost1.scale.set(1,1,1);
	pellet.material.emissive.set('black');
	powerPellet.material.emissive.set('black');
	for(var i=0;i<pellets.children.length;i++)
	{
		pellets.children[i].scale.set(1,1,1);
	}	
	for(var i=0;i<powerPellets.children.length;i++)
	{
		powerPellets.children[i].scale.set(1,1,1);
		
		
	}
}
//TODO: make rotation of pacman more gradual for 3rd person perspective

/**
 * This function is called by the init() method to create the world. 
 */
function createWorld()
{
	/*var hudCanvas = document.createElement('canvas');
	hudCanvas.width = canvas.width;
	hudCanvas.height = canvas.height;
	hudCanvas.style.backgoundColor = "transparent";

	hudBitmap = hudCanvas.getContext ('2d');
	hudBitmap.font = "Normal 40px Arial";
	hudBitmap.textAlign = 'center';
	hudBitmap.fillStyle = "rgba(245 ,245, 245, 0.75)";  
	hudBitmap.fillText('Initializing...', canvas.width / 2, canvas.height / 2); 

	cameraHUD = new THREE.OrthographicCamera(-canvas.width/2, canvas.width/2, canvas.height/2, -canvas.height/2, 0, 30 );
	sceneHUD = new THREE.Scene();
	hudTexture = new THREE.Texture (hudCanvas);
	hudTexture.needsUpdate = true;
	material = new THREE.MeshBasicMaterial ( {map: hudTexture} );
	material.transparent = true;
	planeGeometry = new THREE.PlaneGeometry( canvas.width, canvas.height );
	plane = new THREE.Mesh( planeGeometry, material );
	sceneHUD.add( plane );*/
	
	if(localStorage.getItem("hiscore")!=null)//get hi-score from local storage
	{
		hiScore=localStorage.getItem("hiscore");
	}
	
	
	
	score=0;
	
	sun=new THREE.Object3D();
	var myPac = new THREE.Object3D(); //holds full pacman object	
	pellets= new THREE.Object3D();//	holds all food
	obstructions=new THREE.Object3D();//holds all onstructions
	surfaces=new THREE.Object3D();
	clouds=new THREE.Object3D();
	cloud=new THREE.Object3D();	
	powerPellets=new THREE.Object3D(); 
	 
    renderer.setClearColor("blue"); // Background color for scene.
    scene = new THREE.Scene();
    
	
	buildSkybox();
    // ------------------- Setup cameras and lights ----------------------
    
    mainCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 10000);//main camera, staionary,can be used later for fixed full view with different parameters 
    mainCamera.position.z = 0;
    mainCamera.position.x = -130;
    mainCamera.position.y= 200;
	//camera.rotation.y += 90 * Math.PI / 180;
	
	thirdCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 300);
	thirdCamera.position.z =0; // <-- this is relative to the cube's position
	thirdCamera.position.x=100;//20
	thirdCamera.position.y=10;
	camera=mainCamera;
	//myPac.add(camera);
	var firstCamera=new THREE.PerspectiveCamera;
	firstCamera.position.z=75;
	
	miniMapCamera=new THREE.OrthographicCamera(window.innerWidth / - 16-20, window.innerWidth / 16+40,window.innerHeight / 16+40, window.innerHeight / - 16-20, -30,100 );
	
	miniMapCamera.rotation.x=-Math.PI/2 ;
	miniMapCamera.rotation.z=-Math.PI/2 ;
	miniMapCamera.position.x = 0;
    miniMapCamera.position.y = 2;
    miniMapCamera.position.z = 0;

	//camera=miniMapCamera;
	
    halloweenLight = new THREE.PointLight(0xffa500,1,0,2);//add this light to myPac, and disable all other lights for an awesome spooky effect
	light= new THREE.PointLight(0xffffff,0.5,0,2);
    light2 = new THREE.PointLight(0xffffff,1,0,1);
    light3 = new THREE.DirectionalLight(0xffffff,1,0,1);
    light.position.set(0,10,0);
    light2.position.set(0,30,0);
	light3.position.set(20,-2,20);
	
	
	myPac.add(light);
	scene.add(light2);
	scene.add(light3);
	//objPac.
	////myPac.add(camera);//looks weird, because all of backgound is the same.
   // scene.add(camera);
  
	var gl = canvas.getContext("webgl");
	//var ctx = canvas.getContext ("2d");
	gl.viewport(0, 0, canvas.width, canvas.height);// makes the viewport the same size as the canvas
	var gl2 = minimapCanvas.getContext("webgl");
	//var ctx = canvas.getContext ("2d");
	gl2.viewport(0, 0, minimapCanvas.width, minimapCanvas.height);
    //------------------- Create the scene's visible objects ----------------------
	
 
    var numFrames = 40;
    var offset;
    for (var i = 0; i < numFrames; i++) {// create the frames for pacmans animations
        offset = (i / (numFrames - 1)) * Math.PI;
        pacmanGeometries.push(new THREE.SphereGeometry(PAC_RADIUS, 16, 16, offset, Math.PI * 2 - offset * 2));
        pacMouthGeometries.push(new THREE.SphereGeometry(PAC_RADIUS-0.03, 16, 16, offset, Math.PI *2 - offset * 2));
        pacmanGeometries[i].rotateX(Math.PI / 2);
        pacMouthGeometries[i].rotateX(Math.PI / 2);
    }
	for (var i = 0; i < numFrames; i++) 
	{
		
		ghost1Geometries.push(new THREE.SphereGeometry(2,32,10,0.5,6.3,2,3.4));
		ghost1Geometries[i].rotateZ(Math.PI);
		ghost1Geometries[i].rotateY(0.05*i);
			
	}
    var pacmanMaterial = new THREE.MeshPhongMaterial({ color: 'yellow', side: THREE.FrontSide });
	var pacMouthMaterial=new THREE.MeshBasicMaterial({ color: 'red', side: THREE.BackSide });
	var eyeMaterial=new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	var pacGeometry=new THREE.SphereGeometry(0.3,16,16);
	
	//sun
	//makeSun();

	//one cloud
	//makeCloud();
	//many clouds
//	makeClouds();
	
	pellet=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "pellet"}));
	pellet.position.set(3.5,-3,3.5);
	
	
	var ghostthing=new THREE.Object3D();
	ghostthing.add(new THREE.Mesh(new THREE.SphereGeometry(2,32,10,6,6.3,2,3.4),new THREE.MeshPhongMaterial({color:'pink',side: THREE.BackSide,name: "pellet"})));
	//ghostthing.children[0].rotation.set(0,0,Math.PI);
	//scene.add(ghostthing);
	// bigThing=new THREE.Mesh(new THREE.CubeGeometry(20,20,20),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	//bigThing.position.set(-100,-3,-100);
	//obstructions.add(bigThing);
	
	wall=new THREE.Mesh(new THREE.CubeGeometry(4,4,4),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	wall.position.set(7,-3,7);
	
	//var gate=new THREE.Mesh(new THREE.CubeGeometry(4,4,4),new THREE.MeshPhongMaterial({transparent: true, opacity: 0}));//invisible wall. use so that ghost can go through, not pacman
	//gate.position.set(10,-3,16);
	//obstructions.add(gate);
	
	levelNo=4;
	
	makeLevel(levelNo);

	
	//uncomment all to make floor grassy.only works on firefox//doesnt look too great, but can improve
	
	//https://www.brusheezy.com/textures/20185-seamless-green-grass-textures  credit for grass
	const loader = new THREE.TextureLoader();
	var floorTexture=loader.load('resources/images/grass/GrassGreenTexture0002.jpg');
	floorTexture.repeat.set(15,15);
	floorTexture.wrapS = THREE.RepeatWrapping;
	floorTexture.wrapT = THREE.RepeatWrapping;
	floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshBasicMaterial({side: THREE.BackSide,
	color:'green',//comment out when using a texture
	map: floorTexture//doesn't work in chrome, so only use when using firefox 
	}));
	floor.position.set(0,-5,0);
	floor.rotation.x=Math.PI/2;//make floor on bottom 

	pacman=new THREE.Mesh(pacmanGeometries[10],pacmanMaterial);
	pacMouth=new THREE.Mesh(pacMouthGeometries[10],pacMouthMaterial);	
	var pacEye=new THREE.Mesh(pacGeometry,eyeMaterial);
	
	pacEye.position.set(-1,0.7,2);
	
	
	myPac.add(pacMouth);
	myPac.add(pacman);
	//myPac.add(pacEye);
	var floorCollider=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshBasicMaterial());
	floorCollider.position.set(0,-5,0);
//	surfaces.add(floorCollider);
	
	var ghostHolder=new THREE.Object3D();
	var ball1=new THREE.Mesh(new THREE.SphereGeometry(2,16,16),new THREE.MeshPhongMaterial({color:'pink',side: THREE.DoubleSide,name: "ghost"}));
	//obstructions.add(floor);

	objPac = new Character (PAC_SPEED, -4,0, 8, myPac, pacmanGeometries,obstructions,pellets,powerPellets, "pacman");//make this pacman
	ghost1 = new Character (0.4, 12,5, 12, ghostthing, ghost1Geometries,obstructions);//make first ghost
	ghost1.setTag("ghost");
	
//	objPac.rotation.y=0;
//	console.log(objPac.rotation.y);//down//2pi
//	objPac.rotateY(Math.PI/2);
	
	//console.log(objPac.rotation.y);//right //pi/2
	//objPac.rotateY(Math.PI/2);
	
	//console.log(objPac.rotation.y);//up//0
	//objPac.rotateY(Math.PI/2);
	
	
	//console.log(objPac.rotation.y);//left//-pi/2
	
	scene.add(camera);
	scene.add(powerPellets)
	scene.add(clouds);
	scene.add(floor);
	scene.add(obstructions);
	scene.add(sun);
    scene.add(objPac);
    scene.add(ghost1);
	scene.add(pellets);

	//ctx.drawImage (gl.canvas, 0, 0);
} // end function createWorld()

function createStats() //allows us to see the frames per second, and the graph. change setMode to 1 to see the time taken to render each frame
{
      var stats = new Stats();
      stats.setMode(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';
      return stats;
}

function makeCloud()
{

	//cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshNormalMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//coul almost sunsetty clouds//actually throws error
	cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshPhysicalMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//greyish very defined clouds
	//cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshToonMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//normal, undefined clouds
	cloud.add(cloudBlock);
	for(var i=0;i<20;i++)
	{
		var myCloud=cloudBlock.clone();
		myCloud.position.set(THREE.Math.randFloatSpread( 20 ),THREE.Math.randFloatSpread( 20 ),THREE.Math.randFloatSpread( 50 ));
		cloud.add(myCloud);
	}
}
function makeClouds()//make a set distance, the use the distance formula , and two variables to set the position
{//dont do this. dynamically create and destroy clouds as time goes on
	
	for(var i=0;i<100;i++)
	{
		cloud=new THREE.Object3D();
		makeCloud();
		var myCloud=cloud.clone();
		myCloud.position.set(Math.random()*(2000)-1000,150,Math.random()*(2000)-1000);
		clouds.add(myCloud);
	}
	//sun.position.set(500,100,500);
}

function makeSun()
{
	sunBlock=new THREE.Mesh(new THREE.BoxGeometry(10,10,10),new THREE.MeshLambertMaterial({color:'yellow',side: THREE.DoubleSide,name: "sun",emissive: "yellow",emissiveIntensity:0.1}));
	sun.add(sunBlock);
	for(var i=0;i<4;i++)
	{
		var x,y;
		x=(i<2)?-5:5;
		y=(i%2==0)?-5:5;
		
		var s2=sunBlock.clone();
		s2.position.set(x,5,y);
		sun.add(s2);
	}
	var s2=sunBlock.clone();
	s2.position.set(0,10,0);
	sun.add(s2);
	
	var s2=sunBlock.clone();
	s2.position.set(10,10,0);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,0);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(0,10,10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(0,10,-10);
	sun.add(s2);
	
	var s2=sunBlock.clone();
	s2.position.set(10,10,10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,-10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(10,10,-10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,10);
	sun.add(s2);
	
	for(var i=0;i<4;i++)
	{
		var x,y;
		x=(i<2)?-5:5;
		y=(i%2==0)?-5:5;
		
		var s2=sunBlock.clone();
		s2.position.set(x,15,y);
		sun.add(s2);
	}
	
	var s2=sunBlock.clone();
	s2.position.set(0,20,0);
	sun.add(s2);
	sun.position.set(500,100,500);
	
}

function makeBlock(x,y,z,width,height,depth)
{
	const loader = new THREE.TextureLoader();
	var brickTexture=loader.load('resources/images/brick.jpg');
	//floorTexture.repeat.set(15,15);
	//floorTexture.wrapS = THREE.RepeatWrapping;
	//floorTexture.wrapT = THREE.RepeatWrapping;
	//floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshBasicMaterial({side: THREE.BackSide,
	//color:'green',//comment out when using a texture
	//map: floorTexture//doesn't work in chrome, so only use when using firefox 
	//}));


	var newWall=new THREE.Mesh(new THREE.CubeGeometry(width,height,depth),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));//,map: brickTexture}));
	newWall.position.set(x,y,z);
	obstructions.add(newWall);
}

function makePellets(x,y,z,width,height)
{
	for(var i=0;i<width;i+=4)
	{
		for(var j=0;j<height;j+=4)
		{
			if(height==1)
			{
				var myPellet =pellet.clone();
				myPellet.position.set(x+i-width/4-1,y,z+j-height/4);
				pellets.add(myPellet);
			}
			else
			{
				var myPellet =pellet.clone();
				myPellet.position.set(x+i-width/4,y,z+j-height/4);
				pellets.add(myPellet);
			}
		}
	}
}

function makeLevel(levelNo)//TODO: change main camera view for each level, make it more cmfortable
{
	powerPellet=new THREE.Mesh(new THREE.SphereGeometry(1,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "powerpellet"}));
	
	if (levelNo == 1)
	{

		miniMapCamera.left=window.innerWidth / - 16+20;
		miniMapCamera.right=window.innerWidth /  16;
		miniMapCamera.top=window.innerWidth /  16;
		miniMapCamera.bottom=window.innerWidth / - 16+20;
		miniMapCamera.updateProjectionMatrix();
	//	powerPellet.position.set(12,-3,12);
	
	
	
		camera.position.x=-100;
		camera.position.y=250;
		camera.position.z=0;
		//camera.fov=30;
	
		camera.updateProjectionMatrix();
		if(controls!=null)
		{
		
			controls.update();
			
		}
	
	
		//do powerPellets
		var powerPellet1=powerPellet.clone();
		powerPellet1.position.set(12,-3,-8);
		var powerPellet2=powerPellet.clone();
		powerPellet2.position.set(-4,-3,-8);
		var powerPellet3=powerPellet.clone();
		powerPellet3.position.set(12,-3,32);
		var powerPellet4=powerPellet.clone();
		powerPellet4.position.set(-4,-3,32);
		
		powerPellets.add(powerPellet1);
		powerPellets.add(powerPellet2);
		powerPellets.add(powerPellet3);
		powerPellets.add(powerPellet4);
		//do floor of pellets
		
		
		
		makePellets(4,-3,-4,28,1);
		makePellets(4,-3,28,28,1);
		makePellets(4,-3,7,1,28);
		makePellets(20,-3,7,1,28);
		//makePellets(16,1,18,1,8);

	
	
	
		//middle thing
		makeBlock (12,-3,0,12,4,4);
		makeBlock (12,-3,24,12,4,4);
		makeBlock (8,-3,12,4,4,20);
		makeBlock (16,-3,6,4,4,8);
		makeBlock (16,-3,18,4,4,8);
	
		makePellets(12,1,0,12,1);
		makePellets(12,1,24,12,1);
		makePellets(8,1,9,1,20);
		makePellets(16,1,6,1,8);
		makePellets(16,1,18,1,8);
		
		//top T
		makeBlock (26,-3,12,8,4,4);
		makeBlock (32,-3,12,4,4,28);
		
		makePellets(26,1,12,8,1);
		makePellets(32,1,7,1,28);
		
		//bottom T
		makeBlock (-6,-3,12,8,4,4);
		makeBlock (0,-3,12,4,4,28);
		
		makePellets(-6,1,12,8,1);
		makePellets(0,1,7,1,28);
		
		//left T
		makeBlock(24,-3,0,4,4,12);
		makeBlock(24,-3,-8,20,4,4);
		
		makePellets(24,1,-1,1,12);
		makePellets(22,1,-8,20,1);

		//right T
		makeBlock(24,-3,24,4,4,12);
		makeBlock(24,-3,32,20,4,4);
			
		makePellets(24,1,23,1,12);
		makePellets(22,1,32,20,1);
		
		//left bar
		makeBlock(4,-3,-8,12,4,4);	
		
		makePellets(4,1,-8,12,1);
		
		//right bar
		makeBlock(4,-3,32,12,4,4);	
		
		makePellets(4,1,32,12,1);
		
		//bottom left bar
		makeBlock(-8,-3,-2,4,4,16);
		
		makePellets(-8,1,-4,1,16);
		
		//bottom right bar
		makeBlock(-8,-3,26,4,4,16);
		
		makePellets(-8,1,24,1,16);
		
		//bottom border
		makeBlock(-12,1,26,4,4,16);
		makeBlock(-12,1,-2,4,4,16);
		
		makePellets(-12,5,24,1,16);
		makePellets(-12,5,-4,1,16);
		
		//next level
		makeBlock(-16,5,12,4,4,60);
		
		makePellets(-16,9,-1,1,60);
		
		//next level
		makeBlock(-20,9,32,4,4,20);
		makeBlock(-20,9,-12,4,4,20);
		makeBlock(-20,9,8,4,4,8);
		
		makePellets(-20,13,29,1,20);
		makePellets(-20,13,-12,1,16);
		makePellets(-20,13,8,1,8);
		
		//next level
		makeBlock(-24,13,12,4,4,76);
		
		//makePellets(-24,17,-5,1,76);
			
		//left border
		makeBlock(12,1,-12,52,4,4);
		
		makePellets(2,5,-12,52,1);
		
		//next level
		makeBlock(-8,5,-16,12,4,4);
		makeBlock(8,5,-16,12,4,4);
		makeBlock(36,5,-16,12,4,4);
		
		makePellets(-8,9,-16,12,1);
		makePellets(8,9,-16,12,1);
		makePellets(36,9,-16,12,1);
		
		
		//next level 
		makeBlock(12,9,-20,68,4,4);
		
		makePellets(-2,13,-20,68,1);
		
		//next level 
		makeBlock(12,13,-24,76,4,4);
		
	//	makePellets(-2,17,-24,68,1);
	
	
		//top border
		makeBlock(36,1,2,4,4,8);
		makeBlock(36,1,22,4,4,8);
		
		makePellets(36,5,2,1,8);
		makePellets(36,5,22,1,8);
		
		//next level
		makeBlock(40,5,10,4,4,56);
		
		makePellets(40,9,0,1,52);
		
		//next level
		makeBlock(44,9,-8,4,4,28);
		makeBlock(44,9,32,4,4,28);
		
		makePellets(44,13,-11,1,24);
		makePellets(44,13,27,1,24);
		
		//next level
		makeBlock(48,13,12,4,4,76);
		
	//	makePellets(48,17,-5,1,76);
		
		//right border
		makeBlock(12,1,36,52,4,4);
		
		makePellets(2,5,36,52,1);
		
		//next level
		makeBlock(-8,5,40,12,4,4);
		makeBlock(8,5,40,12,4,4);
		makeBlock(36,5,40,12,4,4);
	
		makePellets(-8,9,40,12,1);
		makePellets(8,9,40,12,1);
		makePellets(36,9,40,12,1);
	
		//next level
		makeBlock(12,9,44,68,4,4);
		
		makePellets(-2,13,44,68,1);
		
		//next level
		makeBlock(12,13,48,68,4,4);
		

		//makePellets(-2,17,48,68,1);
	
	
	
	
		//set up map
		map=[];
		for(var i=0;i<11;i++)
		{
			map[i]=[];
		}
		
		
		//set up small sphere to check if each position is a block or not
		/*var bob=new THREE.Vector3();
		for(var i=0;i<11;i++)
		{
			for(var j=0;j<11;j++)
			{
				bob.set(34-i*4,-1,-6+j*4);//set a and b manually
				for(var k=0;k<obstructions.children.length;k++)//check collision with each block
				{
					var obsBox = new THREE.Box3 (new THREE.Vector3(), new THREE.Vector3());
					obsBox.setFromObject (obstructions.children [i]);
					if(obsBox.containsPoint(bob))
					{
						map[i][j]=1;
						break;
					}
					
					
				}
			}
		}
		*/

	
		
	}
	else if (levelNo == 2)
	{
		miniMapCamera.left = window.innerWidth / - 16 - 50;
		miniMapCamera.right = window.innerWidth /  16 + 70;
		miniMapCamera.top = window.innerWidth /  16 - 10;
		miniMapCamera.bottom = window.innerWidth / - 16 - 10;
		miniMapCamera.updateProjectionMatrix();
	
			//powerpellets and pellets
		powerPellet = new THREE.Mesh (new THREE.SphereGeometry (1, 16, 16), new THREE.MeshPhongMaterial ({color:'skyblue', side: THREE.DoubleSide, name: "powerpellet"}));
		powerPellet.position.set (-40, -3, 12);
		powerPellets.add (powerPellet);

		var powerPellet2 = powerPellet.clone();
		powerPellet2.position.set (20, -3, -8);
		var powerPellet4 = powerPellet.clone();
		powerPellet4.position.set (20, -3, 32);
		
		powerPellets.add (powerPellet2);
		powerPellets.add (powerPellet4);
		
		/*for (var i = 0; i < 13; i++)
		{
			var pellet1 = pellet.clone();
			pellet1.position.set (36 - 4 * i, -3, 12);
			pellets.add (pellet1);
		}

		for (var i = 0; i < 13;i++)
		{
			var pellet1=pellet.clone();
			pellet1.position.set(12,-3,36-4*i);
			pellets.add(pellet1);
		}
		pellets.add(pellet);

		for (var i=0;i<19;i++)
		{
			var myPellet=pellet.clone();
			myPellet.position.set(THREE.Math.randFloatSpread( 100 ),-3,THREE.Math.randFloatSpread( 100 ));
			pellets.add(myPellet);
		}
		//obstructions.add(wall);
		var myPellet=pellet.clone();
		myPellet.position.set(8,0,8);
		pellets.add(myPellet);*/
		
		
		
		//start of cross thing
		/*makeBlock(-2,-3,8,24,4,4);
		makeBlock(-2,-3,16,24,4,4);
		makeBlock(8,-3,-4,4,4,20);
		makeBlock(8,-3,28,4,4,20);
		makeBlock(26,-3,8,24,4,4);
		makeBlock(26,-3,16,24,4,4);
		makeBlock(16,-3,-4,4,4,20);
		makeBlock(16,-3,28,4,4,20);*/
		//end of cross thing


		//MAKING THE PELLETES, MIDDLE PART

		//Right perimeter of middle block
		makePellets (29, -4, 36, 1, 1);
		makePellets (-29,-4,36,74,1);

		//Bottom perimeter of middle block
		makePellets (-48,-4,-4,1,50);

		//Left perimeter of middle block
		makePellets (29, -4, -20, 1, 1);
		makePellets (-29,-4,-20,74,1);

		//Top perimeter of middle block
		makePellets (28,-4,-10,1,26);
		makePellets (28,-4,21,1,20);
		//Rest of these blocks go top to bottom of middle part

		makePellets (25, -4, -12, 1, 1);
		makePellets (25, -4, 8, 1, 1);
		makePellets (25, -4, 16, 1, 1);

		makePellets (20,-4,0,1,48);

		makePellets (-27, -4,-12,64,1);
		makePellets (12, -4,-4,12,1);
		makePellets (12, -4,28,12,1);

		makePellets (5, -4, -16, 1, 1);
		makePellets (4,-4,3,1,44);

		makePellets (1, -4, 12, 1, 1);

		makePellets (-4,-4,3,1,44);

		makePellets (-33, -4, 12, 40, 1);

		makePellets (-40, -4, -4, 1, 18);
		makePellets (-40, -4, 20, 1, 18);

		//PELLETS FOR LEFT SIDE
		//Bridge

		makePellets (4,0,-59,1,52);
		makePellets (5,0,-84,1,1);

		//Box
		makePellets (-0.5, 0, -96, 25, 1);
		makePellets (-1, 0, -72, 8, 1);
		makePellets (11, 0, -72, 8, 1);
		makePellets (16, 0, -87, 1, 22);
		makePellets (-8, 0, -87, 1, 22);


		//PELLETS FOR LEFT SIDE
		//Bridge

		makePellets (-40,0,53,1,52);
		makePellets (-39,0,100,1,1);

		//Box
		makePellets (-45,0,112,25,1);
		makePellets (-28,0,93.5,1,22);
		makePellets (-52,0,94,1,22);
		makePellets (-32,0,88,8,1);
		makePellets (-45,0,88.5,8,1);

		//MAKING THE BLOCKS

		//Makes the Centre block where ghosts will spawn
		makeBlock (12,-3,0,12,4,4);
		makeBlock (12,-3,24,12,4,4);
		makeBlock (8,-3,12,4,4,20);
		makeBlock (16,-3,6,4,4,8);
		makeBlock (16,-3,18,4,4,8);
		//makeBlock (8,1,12,4,4,4);
		//makeBlock (8,5,16,4,4,4);
	
		//T above ghost spawns
		makeBlock (26,-3,12,8,4,4);
		makeBlock (32,-3,8,4,4,60);
		
		//Upside down T  
		//makeBlock (-14,-3,12,3,4,4);
		//makeBlock (-8,-3,-2,4,4,24);
		makeBlock (-8,-3,24,4,4,20);
		//makeBlock (-8,-3,12,4,4,52);
		
		//Two vertical blocks left and right of the spawn
		makeBlock (12,-3,-8,12,4,4);
		makeBlock (12,-3,32,12,4,4);
		
		//Horizontal lines next to Ts, above and below spawn	
		makeBlock (0,-3,0,4,4,20);
		makeBlock (0,-3,24,4,4,20);
		makeBlock (24,-3,-2,4,4,16);
		makeBlock (24,-3,26,4,4,16);
		
		//
		makeBlock (16, -3, -16, 20, 4, 4);

		makeBlock (-4, -3, -16, 12, 4, 4);
		makeBlock (16, -3, 40, 36, 4, 4);

		
    	makeBlock (-22, -3, -16, 48, 4, 4);
		makeBlock (20, -3, 40, 28, 4, 4);
		makeBlock (-24, -3, 40, 52, 4, 4);
		makeBlock (-22, -3, 26, 32, 4, 16);

		//Looooooooooooong path down middle with fat block
		makeBlock (-22, -3, 16, 32, 4, 4);
		makeBlock (-22, -3, 8, 32, 4, 4);

		//Looooooooooong path down on the left with fat block
		makeBlock (20, -3, -24, 28, 4, 4);
		makeBlock (-22, -3, -24, 56, 4, 4);
		makeBlock (-22, -3, -2, 32, 4, 16);

		makeBlock (-52, -3, 8, 4, 4, 68);
		makeBlock (-44, -3, 0, 4, 4, 20);
		makeBlock (-44, -3, 24, 4, 4, 20);

		//Bridge to the left
		makeBlock (4,-3,-50,4,4,48);

		//Box
		makeBlock (4, -3, -72, 20, 4, 4);
		makeBlock (4, -3, -84, 4, 4, 4);
		makeBlock (4, -3, -96, 20, 4, 4);
		makeBlock (16, -3, -84, 4, 4, 28);
		makeBlock (-8, -3, -84, 4, 4, 28);

		//Bridge to the right
		makeBlock (-40,-3,66,4,4,48);

		//Box
		makeBlock (-40, -3, 88, 20, 4, 4);
		makeBlock (-40, -3, 100, 4, 4, 4);
		makeBlock (-40, -3, 112, 20, 4, 4);
		makeBlock (-28, -3, 100, 4, 4, 28);
		makeBlock (-52, -3, 100, 4, 4, 28);
	}
	else if (levelNo == 3)
	{
		
		makeBlock(-108,-3, 0, 12, 4, 216)
		makePellets(-108,0,-50,1,216) 
		makeBlock(0, -3, 108, 228, 4, 12)
		makePellets(108,0,-50,1,216)
		makeBlock(108,-3, -6, 12, 4, 216)
		makePellets(-50, 0, 108 , 216, 1)
		makeBlock(0, -3,-108, 228, 4, 12)
		makePellets(-50, 0, -108 , 216, 1)

		makeBlock(-96, -3, 0, 12, 8, 204)
		makeBlock(-100, -3, 0, 4, 16, 52) //walls 
		makeBlock(-100, -3, 60, 4, 16, 52) //walls
		makeBlock(-100, -3, -60, 4, 16, 52) // walls 
		makeBlock(96, -3, 0, 12, 8, 204)
		makeBlock(100, -3, 0, 4, 16, 52) //walls 
		makeBlock(100, -3, 60, 4, 16, 52) //walls
		makeBlock(100, -3, -60, 4, 16, 52) //walls 
		makeBlock(0, -3, 96, 204, 8, 12)
		makeBlock(0, -3, -96, 204, 8, 12)
		
		makePellets(-96, 4, -50, 1, 196)
		makePellets(96, 4, -50, 1, 196)
		makePellets(-45, 4, -96, 196, 1)
		makePellets(-45, 4, 96, 196, 1)


		makeBlock(-84, -3, 0, 12, 12, 180)
		makeBlock(84, -3, 0, 12, 12, 180)
		makeBlock(0, -3, 84, 180, 12, 12)
		makeBlock(35, -3, 88, 70, 20, 4) //walls 
		makeBlock(-35, -3, 88, 50, 20, 4)//walls
		makeBlock(0, -3, -84, 180, 12, 12)
		makeBlock(35, -3, -88, 70, 20, 4) //walls 
		makeBlock(-35, -3, -88, 50, 20, 4)//walls

		makePellets(-84,5, -40, 1, 170)
		makePellets(84,5, -40, 1, 170)
		makePellets(-40,5, -84, 170, 1)
		makePellets(-40,5, 84, 170, 1)
		
		makeBlock(-72, -3, 0, 12, 16, 156)
		makeBlock(72, -3, 0, 12, 16, 156)
		makeBlock(0, -3, 72, 156, 16, 12)
		makeBlock(0, -3, -72, 156, 16, 12)

		makePellets(-72, 6, -35, 1, 140)
		makePellets( 72, 6, -35, 1, 140)
		makePellets(-35, 6, -72, 156, 1)
		makePellets( -35, 6, 72, 156, 1)


		makeBlock(0, 0, 0, 132, 20, 132)

		makeBlock(-32,12,-62,58,8,4)
		makeBlock(30 ,12,-62,56,8,4)

		makeBlock(-61, 12, -35, 4, 8, 58)
		
		makeBlock(-55, 12, -8, 14, 8, 4)
		makeBlock(-50, 12, -29, 4, 8, 46 )

		makeBlock(0,12,-50,96,8,4)

		makeBlock(58 ,12,0,4,8,108)
		makeBlock(48 ,12,-6,4,8,92)

		makeBlock(4 ,12,62,108,8,4)

		makeBlock(-6 ,12,52,90,8,4)
		makeBlock(-50, 12, 31, 4, 8, 46 )

		makeBlock(-61, 12, 37, 4, 8, 58)
		makeBlock(-55, 12,10, 14, 8, 4)

		makeBlock(0,0,0, 36,24,36)
		makePellets(-16, 14, -6, 1, 36)
		makePellets(16, 14, -6, 1, 36)
		makePellets(-6, 14, 17, 36, 1)
		makePellets(-6, 14, -17, 36, 1)
		makeBlock(0,0,0, 28,28,28)
		makePellets(-12, 16, -4, 1, 28)
		makePellets(12, 16, -4, 1, 28)
		makePellets(-3, 16, -12, 28, 1)
		makePellets(-3, 16, 12, 28, 1)
		makeBlock(0,0,0, 20,32,20)

		makePellets(52, 12, -25, 1, 100)
		makePellets(-30, 12, -55, 110, 1)
		makePellets(-30, 12, 55, 110, 1)
		makePellets(-55, 12, -40, 1, 40)
		makePellets(-55, 12, 25, 1, 40)
	}
	else if(levelNo==4)
	{
		makeBlock (12,-3,0,12,4,4);
		makeBlock (12,-3,24,12,4,4);
		makeBlock (8,-3,12,4,4,20);
		makeBlock (16,-3,6,4,4,8);
		makeBlock (16,-3,18,4,4,8);
	
	//	makePellets(12,1,0,12,1);
	//	makePellets(12,1,24,12,1);
	//	makePellets(8,1,9,1,20);
	//	makePellets(16,1,6,1,8);
	//	makePellets(16,1,18,1,8);
		
		//top T
		makeBlock (26,-3,12,8,4,4);
		makeBlock (32,-3,12,4,4,28);
		
	//	makePellets(26,1,12,8,1);
	//	makePellets(32,1,7,1,28);
		
		//bottom T
		makeBlock (-6,-3,12,8,4,4);
		makeBlock (0,-3,12,4,4,28);
		
	//	makePellets(-6,1,12,8,1);
	//	makePellets(0,1,7,1,28);
		
		//left T
		makeBlock(24,-3,0,4,4,12);
		makeBlock(24,-3,-8,20,4,4);
		
	//	makePellets(24,1,-1,1,12);
	//	makePellets(22,1,-8,20,1);

		//right T
		makeBlock(24,-3,24,4,4,12);
		makeBlock(24,-3,32,20,4,4);
			
	//	makePellets(24,1,23,1,12);
	//	makePellets(22,1,32,20,1);
		
		//left bar
		makeBlock(4,-3,-8,12,4,4);	
		
	//	makePellets(4,1,-8,12,1);
		
		//right bar
		makeBlock(4,-3,32,12,4,4);	
		
	//	makePellets(4,1,32,12,1);
		
		//bottom left bar
		makeBlock(-8,-3,-2,4,4,16);
		
	//	makePellets(-8,1,-4,1,16);
		
		//bottom right bar
		makeBlock(-8,-3,26,4,4,16);
		
	//	makePellets(-8,1,24,1,16);
		
		//bottommer T
		makeBlock (-22,-3,12,8,4,4);
		makeBlock (-16,-3,12,4,4,28);
		
	//	makePellets(-6,1,12,8,1);
	//	makePellets(0,1,7,1,28);
		
		//bottom Tish shapes
		//left
		makeBlock (-18,-3,-8,8,4,4);
		makeBlock (-24,-3,-10,4,4,32);

		//right
		makeBlock (-18,-3,32,8,4,4);
		makeBlock (-24,-3,34,4,4,32);	
		
		//right r
		makeBlock(-8,-3,44,4,4,12);
		makeBlock (-14,-3,40,8,4,4);
		//left r
		
		makeBlock(-8,-3,-20,4,4,12);
		makeBlock (-14,-3,-16,8,4,4);
		
		
		//floor pellets
		makePellets(4,-3,-4,28,1);
		makePellets(4,-3,28,28,1);
		makePellets(4,-3,7,1,28);
		makePellets(20,-3,7,1,28);
		
	}
}

/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incremented 1 before this function is called.
 */
 
function updateForFrame() 
{
	skyboxMesh.rotateY (0.002);//make sky look like its moving
	
	if (objPac.lives == 0)
	{
		document.getElementById ("h1").innerHTML = "GAME OVER";
		document.getElementById ("h2").innerHTML = "YOU DIED";
		document.getElementById ("p").innerHTML = "Your Score: " + objPac.highscore + "                  Hi-Score: " + hiScore;
		document.getElementById ("play").innerHTML = "PLAY AGAIN";
		document.getElementById ("title").innerHTML="Credits:";
		document.getElementById ("grass").innerHTML= "grass texture from https://www.brusheezy.com/textures/20185-seamless-green-grass-textures";

		if (objPac.highscore >= hiScore)
		{
			hiScore = objPac.highscore;
			localStorage.setItem ("hiscore",hiScore);//save hi-score to local storage
			document.getElementById ("p").innerHTML = "Your Score: " + objPac.highscore + "                  New Hi-Score: " + hiScore;
		}

		document.getElementById ("endScreen").style.display = 'inline';
	}//If for when a homie is dead
	if (levelNo != 2)
	{
		if (pellets.children.length == 0)
		{
			levelNo++;
			score += objPac.score;
			reset();
		}
	}
	else if (pellets.children.length == 0)
	{
		canDie = false;
		document.getElementById ("h1").innerHTML = "WELL DONE!";
		document.getElementById ("h2").innerHTML = "YOU COLLECTED ALL PELLETES";
		document.getElementById ("p").innerHTML = "Your Score: " + objPac.highscore + "                  Hi-Score: " + hiScore;
		document.getElementById ("play").innerHTML = "PLAY AGAIN";
		document.getElementById ("title").innerHTML="Credits:";
		document.getElementById ("grass").innerHTML= "grass texture from https://www.brusheezy.com/textures/20185-seamless-green-grass-textures";

		if (objPac.highscore >= hiScore)
		{
			hiScore = objPac.highscore;
			localStorage.setItem ("hiscore",hiScore);//save hi-score to local storage
			document.getElementById ("p").innerHTML = "Your Score: " + objPac.highscore + "                  New Hi-Score: " + hiScore;
		}

		document.getElementById ("endScreen").style.display = 'inline';
	}
	var oof = frameNumber % 20;
	if (oof > 10)
	{
		dir *= -1;
	}//ye, oof
	if (levelNo == 2 && canDie)
	{
		if (objPac.y <= -3 && (objPac.x >=32 || objPac.x <= -51 || objPac.z <= -24 || objPac.z >= 40))
		{
			reset();
			objPac.lives--;
			objPac.score = 0;
		}//If for when pacman is found on the floor and out of bounds
	}//If for setting boundaries for dying in the second level
	
	/*if (frameNumber > 0 && frameNumber % 20 == 0)
	{
		dir *= -1;
	}//If for when 20 frames have passed, reverse direction of pelletes*/
	for (var i = 0; i < pellets.children.length; i++)
	{
		pellets.children [i].translateY (0.05 * dir);
	}//For loop to iterate over all the pelletes
	
  	var myDiv = document.getElementById ("hud");
 	myDiv.innerHTML = "Score: " + objPac.score + "      Lives: " + objPac.lives;


 	var pacSphere;
	var paccy = frameNumber % 20;
    if (paccy > 10) //do opening and closing of mouth animation
    {
        paccy = 20 - paccy;
    }
	
	objPac.animate(paccy);

	objPac.setDirection();
	
	objPac.doCollisions();
	
	objPac.tween();
	

	ghost1.animate (paccy);
	
	ghost1.findChar (objPac, levelNo, halloween);
	
	ghost1.setDirection();
	
	ghost1.doCollisions();

	var charSphere1 = new THREE.Sphere (objPac.getPos(), 2);
	var charSphere2 = new THREE.Sphere (ghost1.getPos(), 2);

	if (!powerMode)
	{
		if (objPac.SphereSphere (charSphere1, charSphere2))
		{
			reset();
			objPac.lives--;
			objPac.score = 0;
		}
	}
	else
	{
		if (objPac.SphereSphere (charSphere1, charSphere2))
		{
			objPac.score += 10;
			ghost1.setPos (12,2000, 12);
			ghostRespawn = 200;
		}
	}//else for when u on power mode

	if (ghostRespawn > 0)
	{
		ghostRespawn--;
		ghost1.setPos (12,2000, 12);
	}//If to give respawn timer
	
	if (halloween)
	{
		objPac.transform.add(halloweenLight);
		objPac.transform.remove(light);
		scene.remove(light2);
		scene.remove(light3);
		pacman.material.emissive.set('orange');
		pellet.material.emissive.set('white');
		powerPellet.material.emissive.set('yellow');
		floor.material.color.set('white');
		renderer.setClearColor("black"); 
		for(var i=0;i<obstructions.children.length;i++)
		{
			obstructions.children[i].material.emissive.set("blue");
		}
		
	}
	else
	{
	
		objPac.transform.remove(halloweenLight);
		objPac.transform.add(light);
		scene.add(light2);
		scene.add(light3);
		pacman.material.emissive.set('black');
		pellet.material.emissive.set('black');
		powerPellet.material.emissive.set('black');
		renderer.setClearColor("blue"); 
		floor.material.color.set('green');
		for(var i=0;i<obstructions.children.length;i++)
		{
			obstructions.children[i].material.emissive.set("black");
		}
	}
	
	if(cameraMode==1)
	{
		objPac.remove(camera);
		camera=mainCamera;
		scene.add(camera);
		
	}
	else if(cameraMode==2)
	{//this is where all the shit that controls the third person camera goes
		scene.remove(camera);
		thirdCamera.position.z =0; // <-- this is relative to the cube's position
		thirdCamera.position.x=20;//20
		thirdCamera.position.y=20;
		thirdCamera.lookAt(objPac.position);
		camera=thirdCamera;
		
		objPac.add(camera);
	}
	
	if(powerPelletEaten)
	{
		powerPelletEaten=false;
		powerMode=true;
		powerPelletTimer=500;//timer for how long power mode lasts
	}
	if(powerMode)
	{
		if(powerPelletTimer==0)
		{
			powerMode = false;
		}
		if(powerPelletTimer > 0)
		{
			powerPelletTimer--;
		}
		
		//do power mode logic here
		halloween=true;
	}
	else
	{
		halloween=false;
	}

	document.getElementById ("mutehud").blur();
}

/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */

function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.enablePan = false; 
    controls.enableZoom = true;
    controls.enableDamping = false;

    function move() {
        controls.update();
        
        render();
    
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}

/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
	frameNumber++;
	updateForFrame();
	render();
	stats.update();
	requestAnimationFrame(doFrame);
}

//TODO: make angles change based on directions being travelled in
function onDocumentKeyDown(event) {
//TODO: when two cameras are introduced, use position relative to player(world) for zoomed out view, relative to character for 3rd person.
    var keyCode = event.which;
    if (keyCode == 83 || keyCode== 40) 
    {//s
		//backwards
		if(cameraMode==1)
		{
			objPac.futureDir="down";
		}
		else
		{
			if(objPac.movingForward)
			{
				objPac.futureDir="down";
			}
			else if(objPac.movingBackward)
			{
				objPac.futureDir="up";
			}
			else if(objPac.movingLeft)
			{
				objPac.futureDir="right";
			}
			else//moving right
			{
				objPac.futureDir="left";
			}
		}
	}
    else if (keyCode == 87 || keyCode==38) 
    {//w
		//forward
		if(cameraMode==1)
		{
			objPac.futureDir="up";
		}
		else
		{
			if(objPac.movingForward)
			{
				objPac.futureDir="up";	
			}
			else if(objPac.movingBackward)
			{
				objPac.futureDir="down";
			}
			else if(objPac.movingLeft)
			{
				objPac.futureDir="left";
			}
			else//moving right
			{
				objPac.futureDir="right";
			}
		}
    } 
    else if (keyCode == 68 || keyCode==39) 
    {//d
		//right
		if(cameraMode==1)
		{
			objPac.futureDir="right";
		}
		else
		{
			if(objPac.movingForward)
			{
				objPac.futureDir="right";
			}
			else if(objPac.movingBackward)
			{
				objPac.futureDir="left";
			}
			else if(objPac.movingLeft)
			{
				objPac.futureDir="up";
			}
			else//moving right
			{
				objPac.futureDir="down";
			}
		}
    }  
    else if (keyCode == 65 || keyCode==37) 
    {//a
		//left
		if(cameraMode==1)
		{
			objPac.futureDir="left";
		}
		else
		{
			if(objPac.movingForward)
			{
				objPac.futureDir="left";
			}
			else if(objPac.movingBackward)
			{
				objPac.futureDir="right";
			}
			else if(objPac.movingLeft)
			{
				objPac.futureDir="down";
			}
			else//moving right
			{
				objPac.futureDir="up";
			}
		}
    } 
    else if (keyCode == 32) 
	{//space
    	objPac.doJump();
		
    }
	else if(keyCode==49)//1
	{
		cameraMode=1;
	}
	else if(keyCode==50)//2
	{ 
		cameraMode=2;
	}
	else if(keyCode==51)//3
	{
		cameraMode=3;
	}
	else if(keyCode==72)//h
	{
	//desnt work anymore, only activated when power pellet eaten, may change
		//halloween= !halloween;
	}
	if(keyCode==82)//r
	{
		reset();
	}
	if (keyCode == 77) //m
	{
		playSound ('theme'); 
	}
}

function reset()
{
	scene = new THREE.Scene();
	powerPellets=new THREE.Object3D();;
	pellets=new THREE.Object3D();;
	obstructions=new THREE.Object3D();
	
	makeLevel (levelNo);//should set walls and pellets and power pellets
	buildSkybox();
	if (levelNo == 3){
		objPac.setPos(-180,0,8)
		ghost1.setPos(-180,20, 12);
	}
	else{
		objPac.setPos(-4,0,8)
		ghost1.setPos(12,5, 12);
	}
		
	objPac.obstructions=obstructions;
	objPac.powerPellets=powerPellets;
	objPac.food=pellets;
	objPac.score=score;
	objPac.resetMovement();
	objPac.futureDir="null";
	
	
	ghost1.obstructions=obstructions;
	ghost1.resetMovement();
	ghost1.futureDir="null";
	
	powerMode=false;
	scene.add(camera);
	scene.add(powerPellets)
	scene.add(clouds);
	scene.add(floor);
	scene.add(obstructions);
	scene.add(sun);
    scene.add(objPac);
    scene.add(ghost1);
	scene.add(pellets);

}

function buildSkybox()
{
	
	var urlPrefix = 'resources/images/miramir/miramar_',

	urls = [

	urlPrefix + 'ft.png',

	urlPrefix + 'bk.png',

	urlPrefix + 'up.png',

	urlPrefix + 'dn.png',

	urlPrefix + 'rt.png',

	urlPrefix + 'lf.png'

	],
	
	
	
	


	/*
	var urlPrefix = 'resources/images/violentdays/violentdays_',

	urls = [

	urlPrefix + 'ft.png',

	urlPrefix + 'bk.png',

	urlPrefix + 'up.png',

	urlPrefix + 'dn.png',

	urlPrefix + 'rt.png',

	urlPrefix + 'lf.png'

	],
	*/
	
	/*
	var urlPrefix = 'resources/images/nightsky/nightsky_',

	urls = [

	urlPrefix + 'ft.png',

	urlPrefix + 'bk.png',

	urlPrefix + 'up.png',

	urlPrefix + 'dn.png',

	urlPrefix + 'rt.png',

	urlPrefix + 'lf.png'

	],
	
	*/

	/*
	var urlPrefix = 'resources/images/rainforest/rainforest_',

	urls = [

	urlPrefix + 'ft.png',

	urlPrefix + 'bk.png',

	urlPrefix + 'up.png',

	urlPrefix + 'dn.png',

	urlPrefix + 'rt.png',

	urlPrefix + 'lf.png'

	],
	*/
	
	
	textureCube = THREE.ImageUtils.loadTextureCube(urls),

	shader = THREE.ShaderLib['cube'],

	uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	uniforms['tCube'].value = textureCube;

	var material = new THREE.ShaderMaterial({

	fragmentShader: shader.fragmentShader,

	vertexShader: shader.vertexShader,

	uniforms: uniforms,

	depthWrite: false,

	side: THREE.DoubleSide

	});

	skyboxMesh = new THREE.Mesh(new THREE.BoxGeometry(1000, 1000, 1000, 1, 1, 1), material);

	scene.add(skyboxMesh);
}

function cloneCanvas (oldCanvas) 
{
    var newCanvas = document.createElement('canvas');
    context = newCanvas.getContext('2d');
    newCanvas.width = oldCanvas.width / 2;
    newCanvas.height = oldCanvas.height / 2;

    context.drawImage (oldCanvas, 0, 0);

    return newCanvas;
}

function resize()
{
	var displayWidth  = canvas.clientWidth;
	var displayHeight = canvas.clientHeight;
 
	// Check if the canvas is not the same size.
	if (canvas.width  != displayWidth || canvas.height != displayHeight) 
	{
		// Make the canvas the same size
		canvas.width  = displayWidth;
		canvas.height = displayHeight;
	}
}

function startGame ()
{
	document.getElementById ("introScreen").style.display = 'none';
}

function replay ()
{
	document.getElementById ("endScreen").style.display = 'none';
	if (first)
	{
		document.getElementById ("theme").pause()
		mute = true;
		document.getElementById ("mute").innerHTML = "Unmute";
		//document.getElementById ("mutehud").innerHTML = "Unmute"
		first = false;
	}//basically i only want it to stop the music the first time the button is pressed
	else
	{
		canDie = true;
		objPac.clear();
		levelNo = 1;
		reset();
	}//
}


function rect (x, y, w, h, c)
{
	context.fillStyle = c;
	context.fillRect (x, y, w, h);
}//Function to draw out 2D rectangle

function text (txt, fnt, x, y, c)
{
	context.fillStyle = c;
	context.font = fnt;
	context.fillText (txt, x, y);
}//Function

function draw()
{
	rect (0, 0, canvas.width, canvas.height, 'black');
	text ('GAME OVER', '75px Comic Sams MS', 10, 30, 'white');
}//Function used to draw the Game Over Screen

function playSound (tag) 
{
	if (mute)
	{
		document.getElementById (tag).play()
		mute = false;
		document.getElementById ("mute").innerHTML = "Mute";
		document.getElementById ("mutehud").style.backgroundImage = 'url(sources/speaker-on-small.png)';
	}
	else
	{
		document.getElementById (tag).pause()
		mute = true;
		document.getElementById ("mute").innerHTML = "Unmute";
		document.getElementById ("mutehud").style.backgroundImage = 'url(sources/speaker-off-small.png)';
	}
} 

function pauseSound (tag) 
{
	if (mute)
	{
		return;
	}
	document.getElementById (tag).pause()
  //document.getElementById('ey').style = "background-color:red";
}
/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        canvas = document.getElementById ("glcanvas");
		minimapCanvas=document.getElementById ("map");
        /*ctx = document.querySelector("#b").getContext("2d");
        canvas2 = cloneCanvas (canvas);*/
        //hudcanvas = document.getElementById("hudcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
		minmapRenderer=new THREE.WebGLRenderer({
			canvas:minimapCanvas,
			antialias:true,
			alpha:false
		});
        //destCtx = document.getElementById ("canvas");
        //var d = destCtx.getContext('2d');
        //d.drawImage (canvas, 50, 50, 100, 100);
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
	requestAnimationFrame(doFrame);
	stats=createStats();
	document.body.appendChild( stats.domElement );
	document.addEventListener("keydown", onDocumentKeyDown, false);
	resize();//allows game to be fullscreen without blurring 
    createWorld();
    installOrbitControls();
    render();
}

</script>
</head>
<body onload="init()">
<canvas id='map'></canvas>

<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<audio loop autoplay id="theme" src="sources/Jarro 8 bit.mp3" type="audio/mp3">
	Your browser does not support the audio element.
</audio>

<div width="window.innerWidth" id="hud" style="color: white">YO
</div>

<div width="window.innerWidth" id="hud2" style="color: white">
	<div>
		<button class="btn" id="mutehud" style="float: right" onclick="playSound ('theme')" type="button" ></button>
	</div>
</div>


<!--
<div id = "introScreen">
	<div id = "introScreenContent">
		<h1>Pac-Man</h1>
		<div id = "btnStart" class = "button" onclick = "startGame()">Start Game</div>
	</div>
</div>

<div width="window.innerWidth" height="window.innerHeight" id = "endScreen">
	<div id = "endScreenContent">
		<h1 id = "txtEndTitle">Game Over</h1>
		<h2 id = "txtEndMessage">You got got homie</h2>
		<div id = "btnReplay" class = "button" onclick = "replay()">Start Game</div>
	</div>
</div>
-->
<div width="window.innerWidth" height="window.innerHeight" id="endScreen">
	<div id = "endScreenContent">
		<br>
		<br>
		<br>
		<h1 id="h1" style="font-family:verdana; text-align: center; font-size:500%;">PAC-MAN</h1>
		<h2 id="h2" style="font-family:verdana; text-align: center; font-size:300%;">IN 3D</h2>
		<p id="p" style="font-family:courier; text-align: center; font-size:200%;">Three.js Project</p><br>
		
		<div id="credits">
		<h1 id="title" style="font-size: 100%"></h1>
		<h2 id="grass" style="font-size: 100%"></h2>
		
		</div>
		<br>
		<button id="play" style="height: 40px; width: 100px; font-weight: bold;"onclick="replay()" type="button">PLAY</button>
		<br>
		<button id="mute" style="float: right;"onclick="playSound ('theme')" type="image" class="button">Mute</button>
		
	</div>
</div>

<canvas width="window.innerWidth" height="window.innerHeight" id="glcanvas"></canvas>
<!--<canvas width="window.innerWidth" height="window.innerHeight" id="hudcanvas"></canvas> -->
</body>
</html>
