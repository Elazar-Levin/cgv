<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>Pacman</title>
<style>
#glcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
}
</style>
<script src="sources/three.js"></script>
<script src="sources/OrbitControls.js"></script>
<script src="sources/stats.js"></script>
<script src="sources/WebVR.js"></script>
<script>



"use strict";

var canvas, renderer, scene, camera,stats; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.



var pacman;//yellow ball shaped thing with huge mouth
var pacMouth;//inside of yellow ball shaped thing with huge mouth
var pacmanGeometries = [];//set of animations for outer pacman
var pacMouthGeometries = [];//set of animations for innerpacman
var floor;//main ground platform that everything stands on
var pellet;//food pellet

var pellets;//Object3D containing all pellets//might have to use array, taking a chance here


var level=0;// current floor pacman is on, so we can do collisions
var cameraMode=1;//3 modes, depending on which number button pressed eg. 1 is fixed full view,2 is 3rd person, 3 is 1st person// not properly done yet
var acceleration=0;//whether or not were using acceleration, or just straight up using speed or using automatic movement
var oneAxis=false;//whether or not we can travel in more than one direction at a time
var halloween=false;//whether halloween mode is on

var pelletsLeft=true;

var movingLeft=false;//attempting continuous movement, where pacman moves with constant velocity in the direction of the last key/s pressed
var movingRight=false;
var movingForward=false;
var movingBackward=false;



var lrAcceleration=0;//left/right acceleration
var fbAcceleration=0;//forward/backward acceleration

var MAX_ACCELERATION=0.5;//fastest speed pacman can achieve
var VETICAL_VELOCITY=0.1;//speed pacman falls if not on ground(gravity kinda)
var PAC_RADIUS=2;//size of pacman
var PAC_SPEED_ACC=0.02;//horizontal speed.because pacman accelerates over time, this needs to be low or hell go out of control 
var PAC_SPEED=0.5;//speed when acceleration is off

var light;  // A light shining from the top of pacman(looks really cool).
var light2;//a general light at the top of the screen
//TODO: add ligt underneath pacman so hes not in shadow
var halloweenLight;



var myPac;//actual full pacman object that well be moving around
/**
 *  The render function draws the scene.
 */
function render() {
    renderer.render(scene, camera);
	
}








/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
	
	




	myPac = new THREE.Object3D(); //holds full pacman object	
	pellets= new THREE.Object3D();	
		
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Setup cameras and lights ----------------------
    
    camera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 300);//main camera, staionary,can be used later for fixed full view with different parameters 
    camera.position.z = 50;
   
    halloweenLight = new THREE.PointLight(0xffa500,1,0,2);//add this light to myPac, and disable all other lights for an awesome spooky effect
	light= new THREE.PointLight(0xffffff,0.5,0,2);
    light2 = new THREE.PointLight(0xffffff,1,0,1);
    light.position.set(0,10,0);
    light2.position.set(0,30,0);
	
	
	myPac.add(light);
	scene.add(light2);
	
	//myPac.add(camera);//looks weird, because all of backgound is the same.
    scene.add(camera);
    resize();//allows game to be fullscreen without blurring
	var gl = canvas.getContext("webgl");
	gl.viewport(0, 0, canvas.width, canvas.height);// makes the viewport the same size as the canvas
    //------------------- Create the scene's visible objects ----------------------
 
	
	
	
	
	
	
    var numFrames = 40;
    var offset;
    for (var i = 0; i < numFrames; i++) {// create the frames for pacmans animations
        offset = (i / (numFrames - 1)) * Math.PI;
        pacmanGeometries.push(new THREE.SphereGeometry(PAC_RADIUS, 16, 16, offset, Math.PI * 2 - offset * 2));
        pacMouthGeometries.push(new THREE.SphereGeometry(PAC_RADIUS-0.03, 16, 16, offset, Math.PI *2 - offset * 2));
        pacmanGeometries[i].rotateX(Math.PI / 2);
        pacMouthGeometries[i].rotateX(Math.PI / 2);
    }

    var pacmanMaterial = new THREE.MeshPhongMaterial({ color: 'yellow', side: THREE.FrontSide });
	
	var pacMouthMaterial=new THREE.MeshBasicMaterial({ color: 'red', side: THREE.BackSide });
	
	
	var eyeMaterial=new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	var pacGeometry=new THREE.SphereGeometry(0.3,16,16);
	
	
	pellet=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "pellet"}));
	pellet.position.set(3.5,-3,3.5);
	
	//pellets.add(pellet)
	
	floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshPhongMaterial({color:'lightyellow',side: THREE.DoubleSide}));
	floor.position.set(0,-5,0);
	floor.rotation.x=Math.PI/2;//make floor on bottom 
	
	pacman=new THREE.Mesh(pacmanGeometries[10],pacmanMaterial);
	pacMouth=new THREE.Mesh(pacMouthGeometries[10],pacMouthMaterial);	
	var pacEye=new THREE.Mesh(pacGeometry,eyeMaterial);
	
	pacEye.position.set(-1,0.7,2);
	
	
	pellets.add(pellet);
	for (var i=0;i<19;i++)
	{
		var myPellet=pellet.clone();
		myPellet.position.set(,-3,)
		
	}
	
	
	
	
	
	
	
	
	
	myPac.add(pacMouth);
	myPac.add(pacman);
	//myPac.add(pacEye);
	

	scene.add(floor);
    scene.add(myPac);
	scene.add(pellets);
	//scene.remove(pellet);
} // end function createWorld()


function createStats() //allows us to see the frames per second, and the graph. change setMode to 1 to see the time taken to render each frame
{
      var stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';

      return stats;
}





/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
 
 
 
 
 
function updateForFrame() {
    
    // Update size and rotation of tempObject.  DELETE THIS!
   
    
	
    

 

	var paccy = frameNumber % 20;
    if (paccy > 10) {//do opening and closing of mouth animation
        paccy = 20 - paccy;
    }
	
	pacman.geometry=pacmanGeometries[paccy];
	pacMouth.geometry=pacMouthGeometries[paccy];
	if(level==0)//if still on ground floor
	{
		if(myPac.position.y-PAC_RADIUS-0.001>=floor.position.y)//stay on floor
		{
			
			myPac.position.y-=VETICAL_VELOCITY;
		
		
		
		}
	}
	//TODO:Consider resseting fbAcceleration when moving left and right, and vice versa(give opinions)
	if(acceleration==1)
	{
		myPac.position.x+=fbAcceleration;//update forward and backward positions
		myPac.position.z+=lrAcceleration;//update left and right positions
	}
	else if(acceleration==2)
	{
		if(movingLeft)
		{
			myPac.position.z+=PAC_SPEED;
		}
		if(movingRight)
		{
			myPac.position.z-=PAC_SPEED;
		}
		if(movingForward)
		{
			myPac.position.x+=PAC_SPEED;
		}
		if(movingBackward)
		{
			myPac.position.x-=PAC_SPEED;
		}
		
	}
	
	if(halloween)
	{
		myPac.add(halloweenLight);
		myPac.remove(light);
		scene.remove(light2);
		pacman.material.emissive.set('orange');
		pellet.material.emissive.set('white');

	}
	else
	{
	
		myPac.remove(halloweenLight);
		myPac.add(light);
		scene.add(light2);
		pacman.material.emissive.set('black');
		pellet.material.emissive.set('black');
	}
	
	
	

	var pacSphere;
	var foodPoint;
	
	pacSphere = new THREE.Sphere(//set original sphers position
	myPac.position,1.5);//make radius 1.5, so sphere only disappears inside pacman
	foodPoint=pellet.position.clone();
	//pacSphere.set(myPac.position,2);
	if(SphereIntersect(pacSphere,foodPoint))
	{
		
		pellets.remove(pellet);
	
	}
	
	
	
	
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        
        render();
    
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}



/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
	frameNumber++;
	updateForFrame();
	render();
	stats.update();
	requestAnimationFrame(doFrame);


	
}


function SphereIntersect(sphere, point) {
// we are using multiplications because it's faster than calling Math.pow
	return sphere.containsPoint(point);
}








//TODO: make angles change based on directions being travelled in
function onDocumentKeyDown(event) {//TODO: introduce keyup event, and then add accelearation, so when you stop its gradual not sudden
//TODO: when two cameras are introduced, use position relative to player(world) for zoomed out view, relative to character for 3rd person.
    var keyCode = event.which;
    if (keyCode == 83 || keyCode== 40) {//s
		//backwards
		if(acceleration==1)
		{
			if(fbAcceleration>=-MAX_ACCELERATION)
			{
				fbAcceleration -= PAC_SPEED_ACC;
				if(oneAxis)
				{
					lrAcceleration=0;//put back in to make him only go forward and backward or left and right, not both
				}
			}
			
		}
		else if(acceleration==0)
		{
			myPac.position.x -= PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even whe buttons arent pressed, like original pacman
		{
		
			movingLeft=false;
			movingRight=false;
			movingForward=false;
			movingBackward=true;
			
		}
		myPac.rotation.y=0;
				
    } else if (keyCode == 87 || keyCode==38) {//w
		//forward
		if(acceleration==1)
		{
			if(fbAcceleration<=MAX_ACCELERATION)
			{
				fbAcceleration+=PAC_SPEED_ACC;
				if(oneAxis)
				{
					lrAcceleration=0;//comment out to make him go both left/right and forward/backward at the same time
				}
			}
		}
		else if(acceleration==0)
		{
			myPac.position.x += PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even whe buttons arent pressed, like original pacman
		{
			
			movingLeft=false;
			movingRight=false;
			movingForward=true;
			movingBackward=false;
						
						
		}
		myPac.rotation.y=Math.PI;
		
    } else if (keyCode == 68 || keyCode==39) {//d
		//right
	
		if(acceleration==1)
		{
			if(lrAcceleration<=MAX_ACCELERATION)
			{
				lrAcceleration += PAC_SPEED_ACC;
				if(oneAxis)
				{
					fbAcceleration=0;
				}
			}
		}
		else if(acceleration==0)
		{
			myPac.position.z += PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even when buttons arent pressed, like original pacman
		{
		
			movingLeft=true;
			movingRight=false;
			movingForward=false;
			movingBackward=false;
			
		}
		myPac.rotation.y=Math.PI/2;
		
    }  else if (keyCode == 65 || keyCode==37) {//a
		//left
		if(acceleration==1)
		{
			if(lrAcceleration>=-MAX_ACCELERATION)
			{
				lrAcceleration-=PAC_SPEED_ACC;
				if(oneAxis)
				{
					fbAcceleration=0;// comment out to make him go both left/right and forward/backward at the same time
				}
			}

		}
		else if(acceleration==0)
		{
			myPac.position.z -= PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even when buttons arent pressed, like original pacman
		{
		
			movingLeft=false;
			movingRight=true;
			movingForward=false;
			movingBackward=false;
			
		}
		myPac.rotation.y=-Math.PI/2;
		
    } else if (keyCode == 32) {//space
        myPac.position.set(0, 0, 0);
		lrAcceleration=0;
		fbAcceleration=0;
    }
	else if(keyCode==49)//1
	{
		cameraMode=1;
	}
	else if(keyCode==50)//2
	{
		cameraMode=2;
	}
	else if(keyCode==51)//3
	{
		cameraMode=3;
	}
	else if(keyCode==13)//enter
	{
		acceleration=(acceleration+1)%3;
	}
	else if(keyCode==187)//equals
	{
		oneAxis= !oneAxis;
	}
	else if(keyCode==72)//h
	{
		halloween= !halloween;
	}
};

function resize()
{
	var displayWidth  = canvas.clientWidth;
	var displayHeight = canvas.clientHeight;
 
	// Check if the canvas is not the same size.
	if (canvas.width  != displayWidth || canvas.height != displayHeight) 
	{
 
		// Make the canvas the same size
		canvas.width  = displayWidth;
		canvas.height = displayHeight;
	}


}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        canvas = document.getElementById("glcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
	requestAnimationFrame(doFrame);
	stats=createStats();
	document.body.appendChild( stats.domElement );
	document.addEventListener("keydown", onDocumentKeyDown, false);

    createWorld();
    installOrbitControls();
    render();
	
}

</script>
</head>
<body onload="init()">


<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>


<canvas width="window.innerWidth" height="window.innerHeight" id="glcanvas"></canvas>


</body>
</html>
