
<!DOCTYPE html>

<head>
<meta charset="UTF-8">
<title>Pacman</title>
<style>
#glcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
}
</style>
<script src="sources/three.js"></script>
<script src="sources/OrbitControls.js"></script>
<script src="sources/stats.js"></script>

<script src="sources/Character.js"></script>

<script>

"use strict";

var canvas, renderer, scene, camera,stats; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

//NB:!!!!!!!! when placing obstacles, make them PAC_RADIUS*2+PAC_SPEED*2 appart, so that if collision doesnt land flush against obstacle, it can still fit
//TODO: when doing collision detection for blocks, do very differently,currently, pacmans speed increases based on the amount of on]bstacles in the scene

var pacman;//yellow ball shaped thing with huge mouth
var pacMouth;//inside of yellow ball shaped thing with huge mouth
var pacmanGeometries = [];//set of animations for outer pacman
var pacMouthGeometries = [];//set of animations for innerpacman
var floor;//main ground platform that everything stands on
var pellet;//food pellet
var wall;//basic obstruction
var objPac;//pacman created by Character.js. 
var sun;//pixelated sun object, made of blocks, with glow inside
var cloud;//pixelated cloud object
var sunBlock;
var cloudBlock;


var clouds;// object containing pixelated cloud objects
var pellets;//Object3D containing all pellets
var obstructions;//Object3D containing all walls/obstructions
var surfaces;//Object3D containing all the surfaces that characters can walk on//doesnt work

var level=0;// current floor pacman is on, so we can do collisions
var cameraMode=1;//3 modes, depending on which number button pressed eg. 1 is fixed full view,2 is 3rd person, 3 is 1st person// not properly done yet
var halloween=false;//whether halloween mode is on

var pelletsLeft=true;


var lrAcceleration=0;//left/right acceleration
var fbAcceleration=0;//forward/backward acceleration

var MAX_ACCELERATION=0.5;//fastest speed pacman can achieve
var VETICAL_VELOCITY=0.3;//speed pacman falls if not on ground(gravity kinda)
var PAC_RADIUS=2;//size of pacman
var PAC_SPEED=0.5;//speed when acceleration is off

var light;  // A light shining from the top of pacman(looks really cool).
var light2;//a general light at the top of the screen
//TODO: add ligt underneath pacman so hes not in shadow
var halloweenLight;
var light3;//light illuminating block



/**
 *  The render function draws the scene.
 */
function render() {
    renderer.render(scene, camera);
	
}
//TODO: make rotation of pacman more gradual for 3rd person perspective



/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
	
	



	sun=new THREE.Object3D();
	var myPac = new THREE.Object3D(); //holds full pacman object	
	pellets= new THREE.Object3D();//	holds all food
	obstructions=new THREE.Object3D();//holds all onstructions
	surfaces=new THREE.Object3D();
	clouds=new THREE.Object3D();
	cloud=new THREE.Object3D();	
	 
    renderer.setClearColor("blue"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Setup cameras and lights ----------------------
    
    var mainCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 10000);//main camera, staionary,can be used later for fixed full view with different parameters 
    mainCamera.position.z = 0;
    mainCamera.position.x = -130;
    mainCamera.position.y= 130;
	//camera.rotation.y += 90 * Math.PI / 180;
	
	var thirdCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 300);
	thirdCamera.position.z = 50; // <-- this is relative to the cube's position
	camera=mainCamera;
	myPac.add(camera);
	var firstCamera=new THREE.PerspectiveCamera;
	firstCamera.position.z=75;
	
	
    halloweenLight = new THREE.PointLight(0xffa500,1,0,2);//add this light to myPac, and disable all other lights for an awesome spooky effect
	light= new THREE.PointLight(0xffffff,0.5,0,2);
    light2 = new THREE.PointLight(0xffffff,1,0,1);
    light3 = new THREE.DirectionalLight(0xffffff,1,0,1);
    light.position.set(0,10,0);
    light2.position.set(0,30,0);
	light3.position.set(20,-2,20);
	
	
	myPac.add(light);
	scene.add(light2);
	scene.add(light3);
	//myPac.add(camera);//looks weird, because all of backgound is the same.
    scene.add(camera);
  
	var gl = canvas.getContext("webgl");
	gl.viewport(0, 0, canvas.width, canvas.height);// makes the viewport the same size as the canvas
    //------------------- Create the scene's visible objects ----------------------
 
	
	
	
	
	
    var numFrames = 40;
    var offset;
    for (var i = 0; i < numFrames; i++) {// create the frames for pacmans animations
        offset = (i / (numFrames - 1)) * Math.PI;
        pacmanGeometries.push(new THREE.SphereGeometry(PAC_RADIUS, 16, 16, offset, Math.PI * 2 - offset * 2));
        pacMouthGeometries.push(new THREE.SphereGeometry(PAC_RADIUS-0.03, 16, 16, offset, Math.PI *2 - offset * 2));
        pacmanGeometries[i].rotateX(Math.PI / 2);
        pacMouthGeometries[i].rotateX(Math.PI / 2);
    }

    var pacmanMaterial = new THREE.MeshPhongMaterial({ color: 'yellow', side: THREE.FrontSide });
	
	var pacMouthMaterial=new THREE.MeshBasicMaterial({ color: 'red', side: THREE.BackSide });
	
	
	var eyeMaterial=new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	var pacGeometry=new THREE.SphereGeometry(0.3,16,16);
	
	
	//sun
	
	makeSun();
	//one cloud
	makeCloud();
	//many clouds
	
	makeClouds();
	
	pellet=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "pellet"}));
	pellet.position.set(3.5,-3,3.5);
	
	// bigThing=new THREE.Mesh(new THREE.CubeGeometry(20,20,20),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	//bigThing.position.set(-100,-3,-100);
	//obstructions.add(bigThing);
	
	wall=new THREE.Mesh(new THREE.CubeGeometry(4,4,4),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	wall.position.set(7,-3,7);
	
	//make longer walls instea, will make everything alot better
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x-i*4,wall.position.y,wall.position.z);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(wall.position.x-i*4,wall.position.y+4,wall.position.z);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x-i*4,wall.position.y,wall.position.z+10);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(wall.position.x-i*4,wall.position.y+4,wall.position.z+10);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x,wall.position.y,wall.position.z-i*4-4);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(wall.position.x,wall.position.y+4,wall.position.z-i*4-4);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x,wall.position.y,wall.position.z-i*4+30);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(wall.position.x,wall.position.y+4,wall.position.z-i*4+30);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	
	for(var i=0;i<5;i++)//top half
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x-i*4)+24,wall.position.y,wall.position.z);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(-(wall.position.x-i*4)+24,wall.position.y+4,wall.position.z);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x-i*4)+24,wall.position.y,wall.position.z+10);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(-(wall.position.x-i*4)+24,wall.position.y+4,wall.position.z+10);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x)+24,wall.position.y,wall.position.z-i*4-4);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(-(wall.position.x)+24,wall.position.y+4,wall.position.z-i*4-4);
		surfaces.add(WallCollider);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x)+24,wall.position.y,wall.position.z-i*4+30);
		obstructions.add(myWall);
		var WallCollider=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial());
		WallCollider.position.set(-(wall.position.x)+24,wall.position.y+4,wall.position.z-i*4+30);
		surfaces.add(WallCollider);
		//surfaces.add(myWall);
	}
	
	
	/*
	//make wall with hidden passage
	//works, but not sure it fits in with the decor
	for(var i=0;i<20;i++)//width
	{
		for(var j=0;j<5;j++)//depth
		{
			for(var k=0;k<5;k++)//height
			{
				var myWall=wall.clone();
				myWall.position.set(-25+4*i,-3+4*k,-100+4*j);
				if(k!=1 && i != 10 && i!=12 && i !=11)
				{
					obstructions.add(myWall);
				}
				else
				{
					scene.add(myWall);
				}
			}
		}
	}
	*/
	floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshPhongMaterial({color:'green',side: THREE.BackSide}));
	floor.position.set(0,-5,0);
	floor.rotation.x=Math.PI/2;//make floor on bottom 
	
	pacman=new THREE.Mesh(pacmanGeometries[10],pacmanMaterial);
	pacMouth=new THREE.Mesh(pacMouthGeometries[10],pacMouthMaterial);	
	var pacEye=new THREE.Mesh(pacGeometry,eyeMaterial);
	
	pacEye.position.set(-1,0.7,2);
	for(var i=0;i<13;i++)
	{
		var pellet1=pellet.clone();
		pellet1.position.set(36-4*i,-3,12);
		pellets.add(pellet1);
	}
	for(var i=0;i<13;i++)
	{
		var pellet1=pellet.clone();
		pellet1.position.set(12,-3,36-4*i);
		pellets.add(pellet1);
	}
	pellets.add(pellet);
	for (var i=0;i<19;i++)
	{
		var myPellet=pellet.clone();
		myPellet.position.set(THREE.Math.randFloatSpread( 100 ),-3,THREE.Math.randFloatSpread( 100 ));
		pellets.add(myPellet);
	}
	
	//obstructions.add(wall);
	
	myPac.add(pacMouth);
	myPac.add(pacman);
	//myPac.add(pacEye);
	var floorCollider=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshBasicMaterial());
	floorCollider.position.set(0,-5,0);
	surfaces.add(floorCollider);
	
	
	objPac = new Character (0.5, 0,0, 0, myPac, pacmanGeometries,obstructions,surfaces,pellets);//make this pacman
	//TODO: make new "floor" which is just an invisible plane used for collisions. well then set up similar planes for every obstruction//kinda set up, doesnt work
	//scene.add(surfaces);
	//clouds.add(cloud);
	
	scene.add(clouds);
	scene.add(floor);
	scene.add(obstructions);
	scene.add(sun);
    scene.add(objPac);
	scene.add(pellets);
	//scene.remove(pellet);
} // end function createWorld()


function createStats() //allows us to see the frames per second, and the graph. change setMode to 1 to see the time taken to render each frame
{
      var stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';

      return stats;
}

function makeCloud()
{
	//cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshNormalMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//coul almost sunsetty clouds//actually throws error
	cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshPhysicalMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//greyish very defined clouds
	//cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshToonMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//normal, undefined clouds
	cloud.add(cloudBlock);
	for(var i=0;i<20;i++)
	{
		var myCloud=cloudBlock.clone();
		myCloud.position.set(THREE.Math.randFloatSpread( 20 ),THREE.Math.randFloatSpread( 20 ),THREE.Math.randFloatSpread( 50 ));
		cloud.add(myCloud);
	}
	
}
function makeClouds()//make a set distance, the use the distance formula , and two variables to set the position
{//dont do this. dynamically create and destroy clouds as time goes on
	
	for(var i=0;i<100;i++)
	{
		cloud=new THREE.Object3D();
		makeCloud();
		var myCloud=cloud.clone();
		myCloud.position.set(Math.random()*(2000)-1000,150,Math.random()*(2000)-1000);
		clouds.add(myCloud);
		
	
	}
	
	//sun.position.set(500,100,500);
}

function makeSun()
{
	sunBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshToonMaterial({color:'yellow',side: THREE.DoubleSide,name: "sun"}));
	sun.add(sunBlock);
	for(var i=0;i<4;i++)
	{
		var x,y;
		x=(i<2)?-5:5;
		y=(i%2==0)?-5:5;
		
		var s2=sunBlock.clone();
		s2.position.set(x,5,y);
		sun.add(s2);
	}
	var s2=sunBlock.clone();
	s2.position.set(0,10,0);
	sun.add(s2);
	
	var s2=sunBlock.clone();
	s2.position.set(10,10,0);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,0);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(0,10,10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(0,10,-10);
	sun.add(s2);
	
	
	var s2=sunBlock.clone();
	s2.position.set(10,10,10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,-10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(10,10,-10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,10);
	sun.add(s2);
	
	for(var i=0;i<4;i++)
	{
		var x,y;
		x=(i<2)?-5:5;
		y=(i%2==0)?-5:5;
		
		var s2=sunBlock.clone();
		s2.position.set(x,15,y);
		sun.add(s2);
	}
	
	var s2=sunBlock.clone();
	
	s2.position.set(0,20,0);
	
	sun.add(s2);
	
	
	sun.position.set(500,100,500);
	
}



/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
 
 
 
 
 
function updateForFrame() {
 	var pacSphere;
	var paccy = frameNumber % 20;
    if (paccy > 10) {//do opening and closing of mouth animation
        paccy = 20 - paccy;
    }
	
	
	
    
	objPac.animate(paccy);
	
	//if(level==0)//if still on ground floor
	//{
	//	//if(myPac.position.y-PAC_RADIUS-0.001>=floor.position.y)//stay on floor
	//	if(objPac.y-PAC_RADIUS-0.001>=floor.position.y)
	//	{
	//		
	//		//myPac.position.y-=VETICAL_VELOCITY;
	//		objPac.setY(objPac.y-VETICAL_VELOCITY);
	//	
	//	
	//	}
	//}
	objPac.doCollisions();
	
	if(halloween)
	{
		objPac.transform.add(halloweenLight);
		objPac.transform.remove(light);
		scene.remove(light2);
		scene.remove(light3);
		pacman.material.emissive.set('orange');
		pellet.material.emissive.set('white');
		wall.material.emissive.set('purple');
		floor.material.color.set('white');
		renderer.setClearColor("black"); 
		//sunBlock.material.emissive.set('white');
	}
	else
	{
	
		objPac.transform.remove(halloweenLight);
		objPac.transform.add(light);
		scene.add(light2);
		scene.add(light3);
		pacman.material.emissive.set('black');
		pellet.material.emissive.set('black');
		wall.material.emissive.set('black');
		renderer.setClearColor("blue"); 
		floor.material.color.set('green');
		//sunBlock.material.emissive.set('yellow');
	}
	
	
	
	
	
	
	
		
	
	
	
	
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.enablePan = false; 
    controls.enableZoom = true;
    controls.enableDamping = false;
    function move() {
        controls.update();
        
        render();
    
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}



/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
	frameNumber++;
	updateForFrame();
	render();
	stats.update();
	requestAnimationFrame(doFrame);


	
}







//TODO: make angles change based on directions being travelled in
function onDocumentKeyDown(event) {
//TODO: when two cameras are introduced, use position relative to player(world) for zoomed out view, relative to character for 3rd person.
    var keyCode = event.which;
    if (keyCode == 83 || keyCode== 40) 
    {//s
		//backwards
		objPac.moveBackward();
		objPac.rotation.y=0;
				
    }
    else if (keyCode == 87 || keyCode==38) 
    {//w
		//forward	
		objPac.moveForward();
		objPac.rotation.y=Math.PI;
		
    } 
    else if (keyCode == 68 || keyCode==39) 
    {//d
		//right
		objPac.moveRight();
		objPac.rotation.y=Math.PI/2;
		
    }  
    else if (keyCode == 65 || keyCode==37) 
    {//a
		//left
		objPac.moveLeft();
		objPac.rotation.y=-Math.PI/2;
		
    } 
    else if (keyCode == 32) 
	{//space
        objPac.setPos(0,0,0);
    }
	else if(keyCode==49)//1
	{
		cameraMode=1;
	}
	else if(keyCode==50)//2
	{
		cameraMode=2;
	}
	else if(keyCode==51)//3
	{
		cameraMode=3;
	}
	else if(keyCode==72)//h
	{
		halloween= !halloween;
	}
}

function resize()
{
	var displayWidth  = canvas.clientWidth;
	var displayHeight = canvas.clientHeight;
 
	// Check if the canvas is not the same size.
	if (canvas.width  != displayWidth || canvas.height != displayHeight) 
	{
 
		// Make the canvas the same size
		canvas.width  = displayWidth;
		canvas.height = displayHeight;
	}


}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        canvas = document.getElementById("glcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
	requestAnimationFrame(doFrame);
	stats=createStats();
	document.body.appendChild( stats.domElement );
	document.addEventListener("keydown", onDocumentKeyDown, false);
	resize();//allows game to be fullscreen without blurring
    createWorld();
    installOrbitControls();
    render();
	
}

</script>
</head>
<body onload="init()">


<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>


<canvas width="window.innerWidth" height="window.innerHeight" id="glcanvas"></canvas>


</body>
</html>
