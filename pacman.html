<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>Pacman</title>
<style>
#glcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
}
</style>
<script src="sources/three.js"></script>
<script src="sources/OrbitControls.js"></script>
<script src="sources/stats.js"></script>
<script src="sources/WebVR.js"></script>
<script>



"use strict";

var canvas, renderer, scene, camera,stats; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

//NB:!!!!!!!! when placing obstacles, make them PAC_RADIUS*2+PAC_SPEED*2 appart, so that if collision doesnt land flush against obstacle, it can still fit
//TODO: when doing collision detection for blocks, do very differently,currently, pacmans speed increases based on the amount of on]bstacles in the scene

var pacman;//yellow ball shaped thing with huge mouth
var pacMouth;//inside of yellow ball shaped thing with huge mouth
var pacmanGeometries = [];//set of animations for outer pacman
var pacMouthGeometries = [];//set of animations for innerpacman
var floor;//main ground platform that everything stands on
var pellet;//food pellet
var wall;//basic obstruction

var pellets;//Object3D containing all pellets
var obstructions;//Object3D containing all walls/obstructions

var level=0;// current floor pacman is on, so we can do collisions
var cameraMode=1;//3 modes, depending on which number button pressed eg. 1 is fixed full view,2 is 3rd person, 3 is 1st person// not properly done yet
var acceleration=0;//whether or not were using acceleration, or just straight up using speed or using automatic movement
var oneAxis=false;//whether or not we can travel in more than one direction at a time
var halloween=false;//whether halloween mode is on

var pelletsLeft=true;

var movingLeft=false;//attempting continuous movement, where pacman moves with constant velocity in the direction of the last key/s pressed
var movingRight=false;
var movingForward=false;
var movingBackward=false;



var lrAcceleration=0;//left/right acceleration
var fbAcceleration=0;//forward/backward acceleration

var MAX_ACCELERATION=0.5;//fastest speed pacman can achieve
var VETICAL_VELOCITY=0.1;//speed pacman falls if not on ground(gravity kinda)
var PAC_RADIUS=2;//size of pacman
var PAC_SPEED_ACC=0.02;//horizontal speed.because pacman accelerates over time, this needs to be low or hell go out of control 
var PAC_SPEED=0.5;//speed when acceleration is off

var light;  // A light shining from the top of pacman(looks really cool).
var light2;//a general light at the top of the screen
//TODO: add ligt underneath pacman so hes not in shadow
var halloweenLight;
var light3;//light illuminating block


var myPac;//actual full pacman object that well be moving around
/**
 *  The render function draws the scene.
 */
function render() {
    renderer.render(scene, camera);
	
}








/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
	
	




	myPac = new THREE.Object3D(); //holds full pacman object	
	pellets= new THREE.Object3D();//	holds all food
	obstructions=new THREE.Object3D();//holds all onstructions
	
    renderer.setClearColor("blue"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Setup cameras and lights ----------------------
    
    var mainCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 300);//main camera, staionary,can be used later for fixed full view with different parameters 
    mainCamera.position.z = 0;
    mainCamera.position.x = -130;
    mainCamera.position.y= 130;
	//camera.rotation.y += 90 * Math.PI / 180;
	
	var thirdCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 300);
	thirdCamera.position.z = 50; // <-- this is relative to the cube's position
	camera=mainCamera;
	myPac.add(camera);
	var firstCamera=new THREE.PerspectiveCamera;
	firstCamera.position.z=75;
	
	
    halloweenLight = new THREE.PointLight(0xffa500,1,0,2);//add this light to myPac, and disable all other lights for an awesome spooky effect
	light= new THREE.PointLight(0xffffff,0.5,0,2);
    light2 = new THREE.PointLight(0xffffff,1,0,1);
    light3 = new THREE.DirectionalLight(0xffffff,1,0,1);
    light.position.set(0,10,0);
    light2.position.set(0,30,0);
	light3.position.set(20,-2,20);
	
	
	myPac.add(light);
	scene.add(light2);
	scene.add(light3);
	//myPac.add(camera);//looks weird, because all of backgound is the same.
    scene.add(camera);
    resize();//allows game to be fullscreen without blurring
	var gl = canvas.getContext("webgl");
	gl.viewport(0, 0, canvas.width, canvas.height);// makes the viewport the same size as the canvas
    //------------------- Create the scene's visible objects ----------------------
 
	
	
	
	
	
    var numFrames = 40;
    var offset;
    for (var i = 0; i < numFrames; i++) {// create the frames for pacmans animations
        offset = (i / (numFrames - 1)) * Math.PI;
        pacmanGeometries.push(new THREE.SphereGeometry(PAC_RADIUS, 16, 16, offset, Math.PI * 2 - offset * 2));
        pacMouthGeometries.push(new THREE.SphereGeometry(PAC_RADIUS-0.03, 16, 16, offset, Math.PI *2 - offset * 2));
        pacmanGeometries[i].rotateX(Math.PI / 2);
        pacMouthGeometries[i].rotateX(Math.PI / 2);
    }

    var pacmanMaterial = new THREE.MeshPhongMaterial({ color: 'yellow', side: THREE.FrontSide });
	
	var pacMouthMaterial=new THREE.MeshBasicMaterial({ color: 'red', side: THREE.BackSide });
	
	
	var eyeMaterial=new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	var pacGeometry=new THREE.SphereGeometry(0.3,16,16);
	
	
	pellet=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "pellet"}));
	pellet.position.set(3.5,-3,3.5);
	
	wall=new THREE.Mesh(new THREE.CubeGeometry(4,4,4),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	wall.position.set(7,-3,7);
	
	
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x-i*4,wall.position.y,wall.position.z);
		obstructions.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x-i*4,wall.position.y,wall.position.z+10);
		obstructions.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x,wall.position.y,wall.position.z-i*4-4);
		obstructions.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(wall.position.x,wall.position.y,wall.position.z-i*4+30);
		obstructions.add(myWall);
	}
	
	for(var i=0;i<5;i++)//top half
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x-i*4)+24,wall.position.y,wall.position.z);
		obstructions.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x-i*4)+24,wall.position.y,wall.position.z+10);
		obstructions.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x)+24,wall.position.y,wall.position.z-i*4-4);
		obstructions.add(myWall);
	}
	for(var i=0;i<5;i++)
	{
		var myWall=wall.clone();
		myWall.position.set(-(wall.position.x)+24,wall.position.y,wall.position.z-i*4+30);
		obstructions.add(myWall);
	}
	
	
	/*
	//make wall with hidden passage
	//works, but not sure it fits inwith the decor
	for(var i=0;i<20;i++)//width
	{
		for(var j=0;j<5;j++)//depth
		{
			for(var k=0;k<5;k++)//height
			{
				var myWall=wall.clone();
				myWall.position.set(-25+4*i,-3+4*k,-100+4*j);
				if(k!=1 && i != 10 && i!=12 && i !=11)
				{
					obstructions.add(myWall);
				}
				else
				{
					scene.add(myWall);
				}
			}
		}
	}
	*/
	floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshPhongMaterial({color:'green',side: THREE.BackSide}));
	floor.position.set(0,-5,0);
	floor.rotation.x=Math.PI/2;//make floor on bottom 
	
	pacman=new THREE.Mesh(pacmanGeometries[10],pacmanMaterial);
	pacMouth=new THREE.Mesh(pacMouthGeometries[10],pacMouthMaterial);	
	var pacEye=new THREE.Mesh(pacGeometry,eyeMaterial);
	
	pacEye.position.set(-1,0.7,2);
	for(var i=0;i<13;i++)
	{
		var pellet1=pellet.clone();
		pellet1.position.set(36-4*i,-3,12);
		pellets.add(pellet1);
	}
	for(var i=0;i<13;i++)
	{
		var pellet1=pellet.clone();
		pellet1.position.set(12,-3,36-4*i);
		pellets.add(pellet1);
	}
	pellets.add(pellet);
	for (var i=0;i<19;i++)
	{
		var myPellet=pellet.clone();
		myPellet.position.set(THREE.Math.randFloatSpread( 100 ),-3,THREE.Math.randFloatSpread( 100 ));
		pellets.add(myPellet);
	}
	
	obstructions.add(wall);
	
	



	
	
	
	
	myPac.add(pacMouth);
	myPac.add(pacman);
	//myPac.add(pacEye);
	
	scene.add(obstructions);
	scene.add(floor);
    scene.add(myPac);
	scene.add(pellets);
	//scene.remove(pellet);
} // end function createWorld()


function createStats() //allows us to see the frames per second, and the graph. change setMode to 1 to see the time taken to render each frame
{
      var stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';

      return stats;
}





/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
 
 
 
 
 
function updateForFrame() {
    
    // Update size and rotation of tempObject.  DELETE THIS!
	
	var pacSphere;
	
	
    

 

	var paccy = frameNumber % 20;
    if (paccy > 10) {//do opening and closing of mouth animation
        paccy = 20 - paccy;
    }
	
	pacSphere = new THREE.Sphere(//set original sphers position
	myPac.position,2);//make radius 1.7, so sphere only disappears inside pacman
	
    
	
	pacman.geometry=pacmanGeometries[paccy];
	pacMouth.geometry=pacMouthGeometries[paccy];
	if(level==0)//if still on ground floor
	{
		if(myPac.position.y-PAC_RADIUS-0.001>=floor.position.y)//stay on floor
		{
			
			myPac.position.y-=VETICAL_VELOCITY;
		
		
		
		}
	}
	
	if(acceleration==1)
	{
		var collides=false; 
		for(var i=0;i<obstructions.children.length;i++)
		{
			var obsBox= new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
			obsBox.setFromObject(obstructions.children[i]);
			//var obs=
			//foodPoint=pellets.children[i].position;
			if(SquareIntersect(pacSphere,obsBox))
			{
				
				collides=true;
			}
	
	
		}
		if(!collides)
		{
			myPac.position.x+=fbAcceleration;//update forward and backward positions
			myPac.position.z+=lrAcceleration;//update left and right positions
		}
	}
	else if(acceleration==2)
	{
	
		if(movingLeft)
		{
			var collides=false;
			for(var i=0;i<obstructions.children.length;i++)
			{
				obstructions.children[i].position.z+=PAC_SPEED;
				var obsBox= new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				obsBox.setFromObject(obstructions.children[i]);
				obstructions.children[i].position.z-=PAC_SPEED;
				
				if(SquareIntersect(pacSphere,obsBox))
				{
					collides=true;
					obsBox.setFromObject(obstructions.children[i]);
					myPac.position.z-=(distanceSphereCube(pacSphere,obsBox));
				}	
				
			}	
			if(!collides)
			{
				myPac.position.z-=PAC_SPEED;		
			}		
			
		}
		if(movingRight)
		{
			var collides=false;
			for(var i=0;i<obstructions.children.length;i++)
			{
				obstructions.children[i].position.z-=PAC_SPEED;
				var obsBox= new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				obsBox.setFromObject(obstructions.children[i]);
				obstructions.children[i].position.z+=PAC_SPEED;
				
				if(SquareIntersect(pacSphere,obsBox))
				{
					collides=true;
					obsBox.setFromObject(obstructions.children[i]);
					myPac.position.z+=(distanceSphereCube(pacSphere,obsBox));
				}	
			}	
			if(!collides)
			{
				myPac.position.z+=PAC_SPEED;		
			}				
			
		}
		if(movingForward)
		{
			var collides=false;
			for(var i=0;i<obstructions.children.length;i++)
			{
				obstructions.children[i].position.x-=PAC_SPEED;
				var obsBox= new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				obsBox.setFromObject(obstructions.children[i]);
				obstructions.children[i].position.x+=PAC_SPEED;
				
				if(SquareIntersect(pacSphere,obsBox))
				{
					collides=true;
					obsBox.setFromObject(obstructions.children[i]);
					myPac.position.x+=(distanceSphereCube(pacSphere,obsBox));
				}	
			}	
			if(!collides)
			{
				myPac.position.x+=PAC_SPEED;	
			}				
			
		}
		if(movingBackward)
		{
			var collides=false;
			for(var i=0;i<obstructions.children.length;i++)
			{
				obstructions.children[i].position.x+=PAC_SPEED;
				var obsBox= new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				obsBox.setFromObject(obstructions.children[i]);
				obstructions.children[i].position.x-=PAC_SPEED;
				
				if(SquareIntersect(pacSphere,obsBox))
				{
					collides=true;
					obsBox.setFromObject(obstructions.children[i]);
					myPac.position.x-=(distanceSphereCube(pacSphere,obsBox));
				}	
			}	
			if(!collides)
			{
				myPac.position.x-=PAC_SPEED;	
			}				
		}
		
		
		
		
		
		
	}
	
	if(halloween)
	{
		myPac.add(halloweenLight);
		myPac.remove(light);
		scene.remove(light2);
		scene.remove(light3);
		pacman.material.emissive.set('orange');
		pellet.material.emissive.set('white');
		wall.material.emissive.set('purple');
		floor.material.color.set('white');
		renderer.setClearColor("black"); 
	}
	else
	{
	
		myPac.remove(halloweenLight);
		myPac.add(light);
		scene.add(light2);
		scene.add(light3);
		pacman.material.emissive.set('black');
		pellet.material.emissive.set('black');
		wall.material.emissive.set('black');
		renderer.setClearColor("blue"); 
		floor.material.color.set('green');
	}
	
	
	//sphere/point/food collisions, anything pacman eats is done here, anything paman crashes into is done before this loop

	var foodPoint;
	pacSphere = new THREE.Sphere(//set original sphers position
	myPac.position,2);//make radius 1.7, so sphere only disappears inside pacman


	for(var i=0;i<pellets.children.length;i++)
	{
		foodPoint=pellets.children[i].position;
		if(SphereIntersect(pacSphere,foodPoint))
		{
			
			pellets.remove(pellets.children[i]);
			return;
		}
	
	
	}
	
	
	
	
		
	
	
	
	
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        
        render();
    
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}



/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
	frameNumber++;
	updateForFrame();
	render();
	stats.update();
	requestAnimationFrame(doFrame);


	
}


function SphereIntersect(sphere, point) {
// we are using multiplications because it's faster than calling Math.pow
	return sphere.containsPoint(point);
}

function SquareIntersect(sphere,Cube)
{
	return sphere.intersectsBox(Cube);
}

function distanceSphereCube(sphere,cube)
{
	//sphere.center()
	
	var closestPoint=new THREE.Vector3();
	cube.clampPoint( sphere.center, closestPoint );
	return Math.sqrt(closestPoint.distanceToSquared( sphere.center )) - sphere.radius-0.1;//last number is offset, the space between the two shapes. the smaller this is, the more ofter unexpected collisions happen
	// If that point is inside the sphere, the AABB and sphere intersect.
				
}




//TODO: make angles change based on directions being travelled in
function onDocumentKeyDown(event) {//TODO: introduce keyup event, and then add accelearation, so when you stop its gradual not sudden
//TODO: when two cameras are introduced, use position relative to player(world) for zoomed out view, relative to character for 3rd person.
    var keyCode = event.which;
    if (keyCode == 83 || keyCode== 40) {//s
		//backwards
		if(acceleration==1)
		{
			if(fbAcceleration>=-MAX_ACCELERATION)
			{
				fbAcceleration -= PAC_SPEED_ACC;
				if(oneAxis)
				{
					lrAcceleration=0;//put back in to make him only go forward and backward or left and right, not both
				}
			}
			
		}
		else if(acceleration==0)
		{
			myPac.position.x -= PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even whe buttons arent pressed, like original pacman
		{
		
			movingLeft=false;
			movingRight=false;
			movingForward=false;
			movingBackward=true;
			
		}
		myPac.rotation.y=0;
				
    } else if (keyCode == 87 || keyCode==38) {//w
		//forward
		if(acceleration==1)
		{
			if(fbAcceleration<=MAX_ACCELERATION)
			{
				fbAcceleration+=PAC_SPEED_ACC;
				if(oneAxis)
				{
					lrAcceleration=0;//comment out to make him go both left/right and forward/backward at the same time
				}
			}
		}
		else if(acceleration==0)
		{
			myPac.position.x += PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even whe buttons arent pressed, like original pacman
		{
			
			movingLeft=false;
			movingRight=false;
			movingForward=true;
			movingBackward=false;
						
						
		}
		myPac.rotation.y=Math.PI;
		
    } else if (keyCode == 68 || keyCode==39) {//d
		//right
	
		if(acceleration==1)
		{
			if(lrAcceleration<=MAX_ACCELERATION)
			{
				lrAcceleration += PAC_SPEED_ACC;
				if(oneAxis)
				{
					fbAcceleration=0;
				}
			}
		}
		else if(acceleration==0)
		{
			myPac.position.z += PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even when buttons arent pressed, like original pacman
		{
		
			movingLeft=false;
			movingRight=true;
			movingForward=false;
			movingBackward=false;
			
		}
		myPac.rotation.y=Math.PI/2;
		
    }  else if (keyCode == 65 || keyCode==37) {//a
		//left
		if(acceleration==1)
		{
			if(lrAcceleration>=-MAX_ACCELERATION)
			{
				lrAcceleration-=PAC_SPEED_ACC;
				if(oneAxis)
				{
					fbAcceleration=0;// comment out to make him go both left/right and forward/backward at the same time
				}
			}

		}
		else if(acceleration==0)
		{
			myPac.position.z -= PAC_SPEED;//original moving system, with no acceleration, and constant velocity
		}
		else//set moving variables, for constant moving, even when buttons arent pressed, like original pacman
		{
		
			movingLeft=true;
			movingRight=false;
			movingForward=false;
			movingBackward=false;
			
		}
		myPac.rotation.y=-Math.PI/2;
		
    } else if (keyCode == 32) {//space
        myPac.position.set(0, 0, 0);
		lrAcceleration=0;
		fbAcceleration=0;
    }
	else if(keyCode==49)//1
	{
		cameraMode=1;
	}
	else if(keyCode==50)//2
	{
		cameraMode=2;
	}
	else if(keyCode==51)//3
	{
		cameraMode=3;
	}
	else if(keyCode==13)//enter
	{
		acceleration=(acceleration+1)%3;
	}
	else if(keyCode==187)//equals
	{
		oneAxis= !oneAxis;
	}
	else if(keyCode==72)//h
	{
		halloween= !halloween;
	}
};

function resize()
{
	var displayWidth  = canvas.clientWidth;
	var displayHeight = canvas.clientHeight;
 
	// Check if the canvas is not the same size.
	if (canvas.width  != displayWidth || canvas.height != displayHeight) 
	{
 
		// Make the canvas the same size
		canvas.width  = displayWidth;
		canvas.height = displayHeight;
	}


}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        canvas = document.getElementById("glcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
	requestAnimationFrame(doFrame);
	stats=createStats();
	document.body.appendChild( stats.domElement );
	document.addEventListener("keydown", onDocumentKeyDown, false);

    createWorld();
    installOrbitControls();
    render();
	
}

</script>
</head>
<body onload="init()">


<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>


<canvas width="window.innerWidth" height="window.innerHeight" id="glcanvas"></canvas>


</body>
</html>
