
<!DOCTYPE html>

<head>
<meta charset="UTF-8">
<title>Pacman</title>
<style>
#glcanvas {
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
}
</style>
<script src="sources/three.js"></script>
<script src="sources/OrbitControls.js"></script>
<script src="sources/stats.js"></script>

<script src="sources/Character.js"></script>

<script>

"use strict";

var canvas, renderer, scene, camera,stats; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

var pacman;//yellow ball shaped thing with huge mouth
var pacMouth;//inside of yellow ball shaped thing with huge mouth
var pacmanGeometries = [];//set of animations for outer pacman
var pacMouthGeometries = [];//set of animations for innerpacman
var floor;//main ground platform that everything stands on
var pellet;//food pellet
var wall;//basic obstruction
var objPac;//pacman created by Character.js. 
var sun;//pixelated sun object, made of blocks, with glow inside
var cloud;//pixelated cloud object
var sunBlock;
var cloudBlock;
var powerPellet;


var clouds;// object containing pixelated cloud objects
var pellets;//Object3D containing all pellets
var obstructions;//Object3D containing all walls/obstructions
var surfaces;//Object3D containing all the surfaces that characters can walk on//doesnt work
var powerPellets;//Object3D containing all powerPellets

var level=0;// current floor pacman is on, so we can do collisions
var cameraMode=1;//3 modes, depending on which number button pressed eg. 1 is fixed full view,2 is 3rd person, 3 is 1st person// not properly done yet
var halloween=false;//whether halloween mode is on
var powerMode=false;
var powerPelletEaten=false;

var mainCamera;
var thirdCamera;

var pelletsLeft=true;

var score;

var powerPelletTimer=0;

var lrAcceleration=0;//left/right acceleration
var fbAcceleration=0;//forward/backward acceleration

var MAX_ACCELERATION=0.5;//fastest speed pacman can achieve
const GRAVITY_CONSTANT=0.1;//speed pacman falls if not on ground(gravity kinda)
var PAC_RADIUS=2;//size of pacman
var PAC_SPEED=0.5//speed //apparently has to have very specific values 

var light;  // A light shining from the top of pacman(looks really cool).
var light2;//a general light at the top of the screen
//TODO: add ligt underneath pacman so hes not in shadow
var halloweenLight;
var light3;//light illuminating block

/**
 *  The render function draws the scene.
 */
function render() 
{
    renderer.render(scene, camera);
	
}
//TODO: make rotation of pacman more gradual for 3rd person perspective

/**
 * This function is called by the init() method to create the world. 
 */
function createWorld()
{
	score=0;
	
	sun=new THREE.Object3D();
	var myPac = new THREE.Object3D(); //holds full pacman object	
	pellets= new THREE.Object3D();//	holds all food
	obstructions=new THREE.Object3D();//holds all onstructions
	surfaces=new THREE.Object3D();
	clouds=new THREE.Object3D();
	cloud=new THREE.Object3D();	
	powerPellets=new THREE.Object3D(); 
	 
    renderer.setClearColor("blue"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Setup cameras and lights ----------------------
    
    mainCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 10000);//main camera, staionary,can be used later for fixed full view with different parameters 
    mainCamera.position.z = 0;
    mainCamera.position.x = -130;
    mainCamera.position.y= 130;
	//camera.rotation.y += 90 * Math.PI / 180;
	
	thirdCamera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 300);
	thirdCamera.position.z =0; // <-- this is relative to the cube's position
	thirdCamera.position.x=100;//20
	thirdCamera.position.y=10;
	camera=mainCamera;
	//myPac.add(camera);
	var firstCamera=new THREE.PerspectiveCamera;
	firstCamera.position.z=75;
	
	
    halloweenLight = new THREE.PointLight(0xffa500,1,0,2);//add this light to myPac, and disable all other lights for an awesome spooky effect
	light= new THREE.PointLight(0xffffff,0.5,0,2);
    light2 = new THREE.PointLight(0xffffff,1,0,1);
    light3 = new THREE.DirectionalLight(0xffffff,1,0,1);
    light.position.set(0,10,0);
    light2.position.set(0,30,0);
	light3.position.set(20,-2,20);
	
	
	myPac.add(light);
	scene.add(light2);
	scene.add(light3);
	//objPac.
	////myPac.add(camera);//looks weird, because all of backgound is the same.
   // scene.add(camera);
  
	var gl = canvas.getContext("webgl");
	gl.viewport(0, 0, canvas.width, canvas.height);// makes the viewport the same size as the canvas
    //------------------- Create the scene's visible objects ----------------------
 
    var numFrames = 40;
    var offset;
    for (var i = 0; i < numFrames; i++) {// create the frames for pacmans animations
        offset = (i / (numFrames - 1)) * Math.PI;
        pacmanGeometries.push(new THREE.SphereGeometry(PAC_RADIUS, 16, 16, offset, Math.PI * 2 - offset * 2));
        pacMouthGeometries.push(new THREE.SphereGeometry(PAC_RADIUS-0.03, 16, 16, offset, Math.PI *2 - offset * 2));
        pacmanGeometries[i].rotateX(Math.PI / 2);
        pacMouthGeometries[i].rotateX(Math.PI / 2);
    }

    var pacmanMaterial = new THREE.MeshPhongMaterial({ color: 'yellow', side: THREE.FrontSide });
	
	var pacMouthMaterial=new THREE.MeshBasicMaterial({ color: 'red', side: THREE.BackSide });
	
	
	var eyeMaterial=new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	var pacGeometry=new THREE.SphereGeometry(0.3,16,16);
	
	
	//sun
	
	makeSun();
	//one cloud
	makeCloud();
	//many clouds
	
	makeClouds();
	
	pellet=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "pellet"}));
	pellet.position.set(3.5,-3,3.5);
	
	// bigThing=new THREE.Mesh(new THREE.CubeGeometry(20,20,20),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	//bigThing.position.set(-100,-3,-100);
	//obstructions.add(bigThing);
	
	wall=new THREE.Mesh(new THREE.CubeGeometry(4,4,4),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	wall.position.set(7,-3,7);
	
	makeLevel(1);

	powerPellet=new THREE.Mesh(new THREE.SphereGeometry(1,16,16),new THREE.MeshPhongMaterial({color:'skyblue',side: THREE.DoubleSide,name: "powerpellet"}));
	powerPellet.position.set(12,-3,12);
	powerPellets.add(powerPellet);
	
	//uncomment all to make floor grassy.only works on firefox//doesnt look too great, but can improve
	
	//const loader = new THREE.TextureLoader();
	//var floorTexture=loader.load('resources/images/grass.png');
	//floorTexture.repeat.set(20,20);
	//floorTexture.wrapS = THREE.RepeatWrapping;
	//floorTexture.wrapT = THREE.RepeatWrapping;
	floor=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshPhongMaterial({side: THREE.BackSide,
	color:'green'//comment out when using a texture
	//map: floorTexture//doesn't work in chrome, so only use when using firefox 
	}));
	floor.position.set(0,-5,0);
	floor.rotation.x=Math.PI/2;//make floor on bottom 
	
	/*heart shape, probably wont use
	var shape = new THREE.Shape();
	var x = -2.5;
	var y = -5;
	shape.moveTo(x + 2.5, y + 2.5);
	shape.bezierCurveTo(x + 2.5, y + 2.5, x + 2, y, x, y);
	shape.bezierCurveTo(x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5);
	shape.bezierCurveTo(x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5);
	shape.bezierCurveTo(x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5);
	shape.bezierCurveTo(x + 8, y + 3.5, x + 8, y, x + 5, y);
	shape.bezierCurveTo(x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5);

	var extrudeSettings = {
	  steps: 6,
	  depth: 1,
	  bevelEnabled: true,
	  bevelThickness: 2,
	  bevelSize: 5,
	  bevelSegments: 5,
	};

	var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
	var heart=new THREE.Mesh(geometry,new THREE.MeshBasicMaterial({color:'red',side: THREE.DoubleSide}));
	heart.scale.set(0.05,0.05,0.05);
	heart.rotation.set(0,0,Math.PI);
	heart.position.set(-10,0,0);
	var heartContainer=new THREE.Object3D();
	heartContainer.add(heart);
	heartContainer.position.set(0,0,-5);
	camera.add(heartContainer);
	*/
	pacman=new THREE.Mesh(pacmanGeometries[10],pacmanMaterial);
	pacMouth=new THREE.Mesh(pacMouthGeometries[10],pacMouthMaterial);	
	var pacEye=new THREE.Mesh(pacGeometry,eyeMaterial);
	
	pacEye.position.set(-1,0.7,2);
	for (var i = 0; i < 13; i++)
	{
		var pellet1 = pellet.clone();
		pellet1.position.set (36 - 4 * i, -3, 12);
		pellets.add (pellet1);
	}

	for (var i = 0; i < 13;i++)
	{
		var pellet1=pellet.clone();
		pellet1.position.set(12,-3,36-4*i);
		pellets.add(pellet1);
	}
	pellets.add(pellet);

	for (var i=0;i<19;i++)
	{
		var myPellet=pellet.clone();
		myPellet.position.set(THREE.Math.randFloatSpread( 100 ),-3,THREE.Math.randFloatSpread( 100 ));
		pellets.add(myPellet);
	}
	//obstructions.add(wall);
	var myPellet=pellet.clone();
	myPellet.position.set(8,0,8);
	pellets.add(myPellet);
	
	myPac.add(pacMouth);
	myPac.add(pacman);
	//myPac.add(pacEye);
	var floorCollider=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,5,5),new THREE.MeshBasicMaterial());
	floorCollider.position.set(0,-5,0);
//	surfaces.add(floorCollider);
	
	objPac = new Character (PAC_SPEED, 0,0, 0, myPac, pacmanGeometries,obstructions,pellets,powerPellets);//make this pacman
	scene.add(camera);
	scene.add(powerPellets)
	scene.add(clouds);
	scene.add(floor);
	scene.add(obstructions);
	scene.add(sun);
    scene.add(objPac);
	scene.add(pellets);
} // end function createWorld()


function createStats() //allows us to see the frames per second, and the graph. change setMode to 1 to see the time taken to render each frame
{
      var stats = new Stats();
      stats.setMode(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';
      return stats;
}

function makeCloud()
{
	//cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshNormalMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//coul almost sunsetty clouds//actually throws error
	cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshPhysicalMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//greyish very defined clouds
	//cloudBlock=new THREE.Mesh(new THREE.CubeGeometry(10,10,10),new THREE.MeshToonMaterial({color:'white',side: THREE.DoubleSide,name: "cloud"}));//normal, undefined clouds
	cloud.add(cloudBlock);
	for(var i=0;i<20;i++)
	{
		var myCloud=cloudBlock.clone();
		myCloud.position.set(THREE.Math.randFloatSpread( 20 ),THREE.Math.randFloatSpread( 20 ),THREE.Math.randFloatSpread( 50 ));
		cloud.add(myCloud);
	}
}
function makeClouds()//make a set distance, the use the distance formula , and two variables to set the position
{//dont do this. dynamically create and destroy clouds as time goes on
	
	for(var i=0;i<100;i++)
	{
		cloud=new THREE.Object3D();
		makeCloud();
		var myCloud=cloud.clone();
		myCloud.position.set(Math.random()*(2000)-1000,150,Math.random()*(2000)-1000);
		clouds.add(myCloud);
	}
	//sun.position.set(500,100,500);
}

function makeSun()
{
	sunBlock=new THREE.Mesh(new THREE.BoxGeometry(10,10,10),new THREE.MeshLambertMaterial({color:'yellow',side: THREE.DoubleSide,name: "sun",emissive: "yellow",emissiveIntensity:0.1}));
	sun.add(sunBlock);
	for(var i=0;i<4;i++)
	{
		var x,y;
		x=(i<2)?-5:5;
		y=(i%2==0)?-5:5;
		
		var s2=sunBlock.clone();
		s2.position.set(x,5,y);
		sun.add(s2);
	}
	var s2=sunBlock.clone();
	s2.position.set(0,10,0);
	sun.add(s2);
	
	var s2=sunBlock.clone();
	s2.position.set(10,10,0);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,0);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(0,10,10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(0,10,-10);
	sun.add(s2);
	
	var s2=sunBlock.clone();
	s2.position.set(10,10,10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,-10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(10,10,-10);
	sun.add(s2);
	var s2=sunBlock.clone();
	s2.position.set(-10,10,10);
	sun.add(s2);
	
	for(var i=0;i<4;i++)
	{
		var x,y;
		x=(i<2)?-5:5;
		y=(i%2==0)?-5:5;
		
		var s2=sunBlock.clone();
		s2.position.set(x,15,y);
		sun.add(s2);
	}
	
	var s2=sunBlock.clone();
	s2.position.set(0,20,0);
	sun.add(s2);
	sun.position.set(500,100,500);
	
}

function makeBlock(x,y,z,width,height,depth)
{
	var newWall=new THREE.Mesh(new THREE.CubeGeometry(width,height,depth),new THREE.MeshPhongMaterial({color:'brown',side: THREE.DoubleSide,name: "wall"}));
	newWall.position.set(x,y,z);
	obstructions.add(newWall);
}

function makeLevel(levelNo)
{
	if(levelNo==1)
	{
		//make surfaces or something, so that characters can walk on walls 
		//start of cross thing
		makeBlock(-2,-3,8,24,4,4);
		makeBlock(-2,-3,16,24,4,4);
		makeBlock(8,-3,-4,4,4,20);
		makeBlock(8,-3,28,4,4,20);
		makeBlock(26,-3,8,24,4,4);
		makeBlock(26,-3,16,24,4,4);
		makeBlock(16,-3,-4,4,4,20);
		makeBlock(16,-3,28,4,4,20);
		//end of cross thing
	}
}


/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
 
 
function updateForFrame() 
{
 	var pacSphere;
	var paccy = frameNumber % 20;
    if (paccy > 10) //do opening and closing of mouth animation
    {
        paccy = 20 - paccy;
    }
	
	objPac.animate(paccy);
	//if(level==0)//if still on ground floor
	//{
	//	//if(myPac.position.y-PAC_RADIUS-0.001>=floor.position.y)//stay on floor
	//	if(objPac.y-PAC_RADIUS-0.001>=floor.position.y)
	//	{
	//		
	//		//myPac.position.y-=VETICAL_VELOCITY;
	//		objPac.setY(objPac.y-VETICAL_VELOCITY);
	//	
	//	
	//	}
	//}
	objPac.setDirection();
	
	objPac.doCollisions();
	
	if(halloween)
	{
		objPac.transform.add(halloweenLight);
		objPac.transform.remove(light);
		scene.remove(light2);
		scene.remove(light3);
		pacman.material.emissive.set('orange');
		pellet.material.emissive.set('white');
		powerPellet.material.emissive.set('yellow');
		floor.material.color.set('white');
		renderer.setClearColor("black"); 
		for(var i=0;i<obstructions.children.length;i++)
		{
			obstructions.children[i].material.emissive.set("blue");
		}
		
	}
	else
	{
	
		objPac.transform.remove(halloweenLight);
		objPac.transform.add(light);
		scene.add(light2);
		scene.add(light3);
		pacman.material.emissive.set('black');
		pellet.material.emissive.set('black');
		powerPellet.material.emissive.set('black');
		renderer.setClearColor("blue"); 
		floor.material.color.set('green');
		for(var i=0;i<obstructions.children.length;i++)
		{
			obstructions.children[i].material.emissive.set("black");
		}
	}
	
	if(cameraMode==1)
	{
		objPac.remove(camera);
		camera=mainCamera;
		scene.add(camera);
		
	}
	else if(cameraMode==2)
	{
		scene.remove(camera);
		camera=thirdCamera;
		objPac.add(camera);
	}
	
	if(powerPelletEaten)
	{
		powerPelletEaten=false;
		powerMode=true;
		powerPelletTimer=500;//timer for how long power mode lasts
	}
	if(powerMode)
	{
		if(powerPelletTimer==0)
		{
			powerMode=false;
		}
		if(powerPelletTimer>0)
		{
			powerPelletTimer--;
		}
		//do power mode logic here
	}
	
	
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.enablePan = false; 
    controls.enableZoom = true;
    controls.enableDamping = false;

    function move() {
        controls.update();
        
        render();
    
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}



/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
	frameNumber++;
	updateForFrame();
	render();
	stats.update();
	requestAnimationFrame(doFrame);
}

//TODO: make angles change based on directions being travelled in
function onDocumentKeyDown(event) {
//TODO: when two cameras are introduced, use position relative to player(world) for zoomed out view, relative to character for 3rd person.
    var keyCode = event.which;
    if (keyCode == 83 || keyCode== 40) 
    {//s
		//backwards
		objPac.futureDir="down";
	}
    else if (keyCode == 87 || keyCode==38) 
    {//w
		//forward	
		objPac.futureDir="up";
    } 
    else if (keyCode == 68 || keyCode==39) 
    {//d
		//right
		objPac.futureDir="right";
    }  
    else if (keyCode == 65 || keyCode==37) 
    {//a
		//left
		objPac.futureDir="left";
    } 
    else if (keyCode == 32) 
	{//space
      //  if(!objPac.jumping && objPac.canJump())
		//{
	//		jumping =true;
	//	}
		//objPac.setPos(7,10,7);
		objPac.doJump();
		//halloween = !halloween;
    }
	else if(keyCode==49)//1
	{
		cameraMode=1;
	}
	else if(keyCode==50)//2
	{
		cameraMode=2;
	}
	else if(keyCode==51)//3
	{
		cameraMode=3;
	}
	else if(keyCode==72)//h
	{
		halloween= !halloween;
	}
}

function resize()
{
	var displayWidth  = canvas.clientWidth;
	var displayHeight = canvas.clientHeight;
 
	// Check if the canvas is not the same size.
	if (canvas.width  != displayWidth || canvas.height != displayHeight) 
	{
 
		// Make the canvas the same size
		canvas.width  = displayWidth;
		canvas.height = displayHeight;
	}


}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
        canvas = document.getElementById("glcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
	requestAnimationFrame(doFrame);
	stats=createStats();
	document.body.appendChild( stats.domElement );
	document.addEventListener("keydown", onDocumentKeyDown, false);
	resize();//allows game to be fullscreen without blurring 
    createWorld();
    installOrbitControls();
    render();
	
}

</script>
</head>
<body onload="init()">


<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>


<canvas width="window.innerWidth" height="window.innerHeight" id="glcanvas"></canvas>


</body>
</html>
